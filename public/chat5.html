<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat - UniConnect</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Socket.IO -->
    <script src="/socket.io/socket.io.js"></script>
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- WebRTC Adapter -->
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
    
    <style>
        :root {
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --online-color: #10B981;
            --offline-color: #9CA3AF;
            --typing-color: #667eea;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow-x: hidden;
        }
        
        .gradient-bg {
            background: var(--primary-gradient);
        }
        
        .message-bubble {
            max-width: 70%;
            border-radius: 18px;
            padding: 12px 16px;
            margin: 4px 0;
            position: relative;
            animation: fadeIn 0.3s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .message-bubble.sent {
            background: var(--primary-gradient);
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 4px;
        }
        
        .message-bubble.received {
            background: #F3F4F6;
            color: #1F2937;
            margin-right: auto;
            border-bottom-left-radius: 4px;
        }
        
        .message-time {
            font-size: 11px;
            opacity: 0.8;
            margin-top: 4px;
            text-align: right;
        }
        
        .typing-indicator {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            background: #F3F4F6;
            border-radius: 18px;
            width: fit-content;
            margin: 8px 0;
        }
        
        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--typing-color);
            margin: 0 2px;
            animation: typing 1.4s infinite;
        }
        
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-8px); }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Call UI Styles */
        .call-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            z-index: 1000;
            display: none;
        }
        
        .video-grid {
            display: grid;
            grid-template-columns: 1fr;
            height: 100%;
            gap: 10px;
            padding: 20px;
        }
        
        @media (min-width: 768px) {
            .video-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        .video-container {
            position: relative;
            background: #222;
            border-radius: 10px;
            overflow: hidden;
            min-height: 200px;
        }
        
        .video-container.local video {
            transform: scaleX(-1);
        }
        
        .video-label {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 10;
        }
        
        .call-controls {
            position: absolute;
            bottom: 30px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 20px;
            z-index: 1001;
        }
        
        .call-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            outline: none;
        }
        
        .call-btn:hover {
            transform: scale(1.1);
        }
        
        .call-btn.end-call {
            background: #EF4444;
            color: white;
        }
        
        .call-btn.toggle-audio,
        .call-btn.toggle-video {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }
        
        .call-btn.active {
            background: #10B981;
        }
        
        .call-btn.inactive {
            background: #EF4444;
        }
        
        .call-timer {
            position: absolute;
            top: 20px;
            left: 0;
            right: 0;
            text-align: center;
            color: white;
            font-size: 18px;
            font-weight: bold;
            z-index: 1001;
        }
        
        /* Incoming Call Modal */
        .incoming-call-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }
        
        .incoming-call-content {
            background: white;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        /* Scrollbar styling */
        .messages-container::-webkit-scrollbar {
            width: 6px;
        }
        
        .messages-container::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        .messages-container::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }
        
        .messages-container::-webkit-scrollbar-thumb:hover {
            background: #a1a1a1;
        }
        
        /* Voice message styles */
        .voice-message {
            background: var(--primary-gradient);
            color: white;
            border-radius: 20px;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            width: 200px;
            cursor: pointer;
        }
        
        .voice-message:hover {
            opacity: 0.9;
        }
        
        .voice-wave {
            display: flex;
            align-items: center;
            gap: 2px;
            height: 20px;
            margin-left: 10px;
            margin-right: 10px;
        }
        
        .voice-bar {
            width: 2px;
            background: white;
            border-radius: 1px;
            animation: voiceWave 1s ease-in-out infinite;
        }
        
        .voice-bar:nth-child(2) { animation-delay: 0.1s; }
        .voice-bar:nth-child(3) { animation-delay: 0.2s; }
        .voice-bar:nth-child(4) { animation-delay: 0.3s; }
        .voice-bar:nth-child(5) { animation-delay: 0.4s; }
        
        @keyframes voiceWave {
            0%, 100% { height: 4px; }
            50% { height: 16px; }
        }
        
        /* Recording indicator */
        .recording-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #EF4444;
            color: white;
            padding: 12px 16px;
            border-radius: 25px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 1000;
            animation: pulse 1.5s infinite;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* Status indicators */
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid white;
            position: absolute;
            bottom: 0;
            right: 0;
        }
        
        .status-dot.online {
            background: var(--online-color);
        }
        
        .status-dot.offline {
            background: var(--offline-color);
        }
        
        /* Loading animation */
        .loading-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* File message styles */
        .file-message {
            background: #F3F4F6;
            border-radius: 10px;
            padding: 12px;
            display: flex;
            align-items: center;
            max-width: 300px;
        }
        
        .file-icon {
            width: 40px;
            height: 40px;
            background: #667eea;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            color: white;
        }
        
        .file-info {
            flex: 1;
            overflow: hidden;
        }
        
        .file-name {
            font-weight: 500;
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .file-size {
            font-size: 12px;
            color: #6B7280;
            margin-top: 2px;
        }
        
        /* Message status icons */
        .message-status {
            display: inline-flex;
            margin-left: 4px;
        }
        
        .message-status i {
            font-size: 12px;
        }
        
        /* Call ringing animation */
        .ringing {
            animation: ring 1s infinite;
        }
        
        @keyframes ring {
            0%, 100% { transform: rotate(0); }
            25% { transform: rotate(5deg); }
            75% { transform: rotate(-5deg); }
        }
        
        /* Audio visualization */
        .audio-visualizer {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 30px;
            width: 100px;
        }
        
        .audio-bar {
            width: 3px;
            background: white;
            margin: 0 1px;
            border-radius: 1.5px;
            animation: audioWave 1s ease-in-out infinite;
        }
        
        @keyframes audioWave {
            0%, 100% { height: 5px; }
            50% { height: 15px; }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <!-- Navigation -->
    <nav class="gradient-bg text-white h-16 shadow-lg sticky top-0 z-50">
        <div class="container mx-auto px-4 h-full flex items-center justify-between">
            <div class="flex items-center space-x-3">
                <a href="/messages.html" class="p-2 hover:bg-white/10 rounded-full transition">
                    <i class="fas fa-arrow-left"></i>
                </a>
                <div class="flex items-center space-x-3">
                    <div class="relative">
                        <img id="chatUserAvatar" src="https://via.placeholder.com/150" class="w-10 h-10 rounded-full object-cover border-2 border-white">
                        <div id="chatUserStatus" class="status-dot offline"></div>
                    </div>
                    <div>
                        <h1 id="chatUserName" class="font-bold text-lg">Loading...</h1>
                        <p id="chatUserUniversity" class="text-sm text-white/80"></p>
                    </div>
                </div>
            </div>
            <div class="flex items-center space-x-2">
                <button id="videoCallBtn" onclick="startVideoCall()" class="p-2 hover:bg-white/10 rounded-full transition" title="Video Call">
                    <i class="fas fa-video"></i>
                </button>
                <button id="voiceCallBtn" onclick="startVoiceCall()" class="p-2 hover:bg-white/10 rounded-full transition" title="Voice Call">
                    <i class="fas fa-phone"></i>
                </button>
                <button onclick="toggleUserInfo()" class="p-2 hover:bg-white/10 rounded-full transition" title="User Info">
                    <i class="fas fa-info-circle"></i>
                </button>
            </div>
        </div>
    </nav>

    <!-- Main Chat Container -->
    <div class="container mx-auto flex h-[calc(100vh-4rem)]">
        <!-- Chat Area -->
        <div class="flex-1 flex flex-col bg-white">
            <!-- Messages Container -->
            <div id="messagesContainer" class="messages-container flex-1 overflow-y-auto p-4 space-y-4">
                <!-- Loading indicator -->
                <div id="loadingIndicator" class="text-center py-8">
                    <div class="loading-spinner"></div>
                    <p class="text-gray-500 mt-2">Loading messages...</p>
                </div>
                <!-- Messages will be loaded here -->
            </div>
            
            <!-- Typing Indicator -->
            <div id="typingIndicator" class="hidden px-6 pb-2">
                <div class="typing-indicator">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <span class="ml-2 text-sm text-gray-600" id="typingText"></span>
                </div>
            </div>
            
            <!-- Message Input Area -->
            <div class="border-t border-gray-200 p-4 bg-white shadow-md">
                <!-- Recording Indicator -->
                <div id="recordingIndicator" class="recording-indicator hidden">
                    <i class="fas fa-microphone animate-pulse"></i>
                    <span id="recordingTime">00:00</span>
                    <button onclick="stopRecording()" class="ml-4 text-sm bg-white/20 px-3 py-1 rounded-full hover:bg-white/30 transition">
                        <i class="fas fa-stop mr-1"></i> Stop
                    </button>
                </div>
                
                <div class="flex items-end space-x-3">
                    <!-- Attachment Buttons -->
                    <div class="flex space-x-1">
                        <button onclick="attachFile()" class="p-3 text-gray-600 hover:bg-gray-100 rounded-full transition" title="Attach File">
                            <i class="fas fa-paperclip"></i>
                        </button>
                        <button onclick="startVoiceRecording()" class="p-3 text-gray-600 hover:bg-gray-100 rounded-full transition" title="Record Voice">
                            <i class="fas fa-microphone"></i>
                        </button>
                        <button onclick="attachImage()" class="p-3 text-gray-600 hover:bg-gray-100 rounded-full transition" title="Send Image">
                            <i class="fas fa-image"></i>
                        </button>
                        <button onclick="attachVideo()" class="p-3 text-gray-600 hover:bg-gray-100 rounded-full transition" title="Send Video">
                            <i class="fas fa-video"></i>
                        </button>
                    </div>
                    
                    <!-- Message Input -->
                    <div class="flex-1">
                        <textarea 
                            id="messageInput" 
                            class="w-full px-4 py-3 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent resize-none"
                            placeholder="Type a message..." 
                            rows="1"
                            oninput="autoResize(this)"
                            onkeydown="handleKeyDown(event)"
                            onfocus="startTyping()"
                            onblur="stopTyping()"></textarea>
                    </div>
                    
                    <!-- Send Button -->
                    <button 
                        id="sendButton"
                        onclick="sendMessage()" 
                        class="gradient-bg text-white p-3 rounded-xl font-semibold hover:opacity-90 transition disabled:opacity-50 disabled:cursor-not-allowed"
                        disabled>
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- User Info Sidebar -->
        <div id="userInfoSidebar" class="w-80 border-l border-gray-200 bg-white overflow-y-auto hidden lg:block">
            <div class="p-6">
                <!-- User Info Header -->
                <div class="text-center mb-8">
                    <div class="relative inline-block mb-4">
                        <img id="sidebarUserAvatar" src="https://via.placeholder.com/150" class="w-24 h-24 rounded-full object-cover border-4 border-white shadow-lg">
                        <div id="sidebarUserStatus" class="status-dot offline" style="width: 16px; height: 16px; border-width: 3px;"></div>
                    </div>
                    <h3 id="sidebarUserName" class="text-xl font-bold text-gray-800"></h3>
                    <p id="sidebarUserUsername" class="text-gray-600 mb-2"></p>
                    <div id="sidebarUserStatusText" class="inline-flex items-center px-3 py-1 rounded-full text-sm mb-4 bg-gray-100 text-gray-700">
                        <span class="w-2 h-2 rounded-full mr-2 bg-gray-500"></span>
                        <span>Offline</span>
                    </div>
                </div>
                
                <!-- User Details -->
                <div class="space-y-6">
                    <!-- University Info -->
                    <div>
                        <h4 class="font-semibold text-gray-700 mb-3 text-lg">
                            <i class="fas fa-university mr-2"></i> University
                        </h4>
                        <div class="space-y-2">
                            <p id="sidebarUserUniversity" class="text-gray-700"></p>
                            <p id="sidebarUserStudyGroup" class="text-gray-600 text-sm">
                                <i class="fas fa-users mr-1"></i> Study Group: 
                                <span id="studyGroupText"></span>
                            </p>
                        </div>
                    </div>
                    
                    <!-- Contact Info -->
                    <div>
                        <h4 class="font-semibold text-gray-700 mb-3 text-lg">
                            <i class="fas fa-address-book mr-2"></i> Contact
                        </h4>
                        <div class="space-y-3">
                            <div class="flex items-center">
                                <i class="fas fa-phone text-gray-400 w-5 mr-3"></i>
                                <span id="sidebarUserPhone" class="text-gray-700"></span>
                            </div>
                            <div class="flex items-center">
                                <i class="fas fa-envelope text-gray-400 w-5 mr-3"></i>
                                <span id="sidebarUserEmail" class="text-gray-700"></span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Actions -->
                    <div class="pt-6 border-t border-gray-200">
                        <div class="space-y-3">
                            <button onclick="viewUserProfile()" 
                                    class="w-full gradient-bg text-white py-3 rounded-lg font-semibold hover:opacity-90 transition flex items-center justify-center">
                                <i class="fas fa-user mr-2"></i> View Profile
                            </button>
                        </div>
                    </div>
                    
                    <!-- Call Controls -->
                    <div class="pt-6 border-t border-gray-200">
                        <h4 class="font-semibold text-gray-700 mb-4 text-lg">
                            <i class="fas fa-phone-alt mr-2"></i> Call Options
                        </h4>
                        <div class="space-y-3">
                            <button onclick="startVideoCall()" 
                                    id="sidebarVideoCallBtn"
                                    class="w-full gradient-bg text-white py-3 rounded-lg font-semibold hover:opacity-90 transition flex items-center justify-center">
                                <i class="fas fa-video mr-2"></i> Video Call
                            </button>
                            <button onclick="startVoiceCall()" 
                                    id="sidebarVoiceCallBtn"
                                    class="w-full bg-blue-100 text-blue-600 py-3 rounded-lg font-semibold hover:bg-blue-200 transition flex items-center justify-center">
                                <i class="fas fa-phone mr-2"></i> Voice Call
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Video/Audio Call Interface -->
    <div id="callContainer" class="call-container">
        <div class="video-grid" id="videoGrid">
            <!-- Local video -->
            <div class="video-container local">
                <video id="localVideo" autoplay muted playsinline></video>
                <div class="video-label">You</div>
            </div>
            
            <!-- Remote video -->
            <div class="video-container remote">
                <video id="remoteVideo" autoplay playsinline></video>
                <div class="video-label" id="remoteUserName">Connecting...</div>
            </div>
        </div>
        
        <div class="call-timer" id="callTimer">00:00</div>
        
        <div class="call-controls">
            <button id="toggleAudioBtn" class="call-btn toggle-audio active" onclick="toggleAudio()" title="Toggle Microphone">
                <i class="fas fa-microphone"></i>
            </button>
            <button id="toggleVideoBtn" class="call-btn toggle-video active" onclick="toggleVideo()" title="Toggle Camera">
                <i class="fas fa-video"></i>
            </button>
            <button class="call-btn end-call" onclick="endCall()" title="End Call">
                <i class="fas fa-phone-slash"></i>
            </button>
        </div>
    </div>

    <!-- Incoming Call Modal -->
    <div id="incomingCallModal" class="incoming-call-modal hidden">
        <div class="incoming-call-content">
            <div class="mb-6">
                <img id="callerAvatar" src="https://via.placeholder.com/150" class="w-24 h-24 rounded-full mx-auto mb-4 border-4 border-white shadow-lg ringing">
                <h3 id="callerName" class="text-2xl font-bold text-gray-800">Incoming Call</h3>
                <p id="callType" class="text-gray-600 mt-1">Video Call</p>
            </div>
            <div class="flex justify-center space-x-4">
                <button onclick="acceptCall()" 
                        class="bg-green-500 text-white px-8 py-3 rounded-full font-semibold hover:bg-green-600 transition flex items-center">
                    <i class="fas fa-phone mr-2"></i> Accept
                </button>
                <button onclick="rejectCall()" 
                        class="bg-red-500 text-white px-8 py-3 rounded-full font-semibold hover:bg-red-600 transition flex items-center">
                    <i class="fas fa-phone-slash mr-2"></i> Reject
                </button>
            </div>
        </div>
    </div>

    <!-- Call Connecting Modal -->
    <div id="callConnectingModal" class="incoming-call-modal hidden">
        <div class="incoming-call-content">
            <div class="mb-6">
                <div class="loading-spinner mx-auto mb-4"></div>
                <h3 class="text-2xl font-bold text-gray-800" id="connectingText">Calling...</h3>
                <p class="text-gray-600 mt-1" id="connectingSubtext">Waiting for answer</p>
            </div>
            <div class="flex justify-center">
                <button onclick="cancelCall()" 
                        class="bg-red-500 text-white px-8 py-3 rounded-full font-semibold hover:bg-red-600 transition flex items-center">
                    <i class="fas fa-times mr-2"></i> Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- Notification Toast -->
    <div id="notificationToast" class="fixed top-4 right-4 bg-gray-800 text-white px-4 py-3 rounded-lg shadow-lg z-50 transform transition-transform duration-300 translate-x-full">
        <div class="flex items-center">
            <i class="fas fa-info-circle mr-3"></i>
            <span id="notificationText"></span>
        </div>
    </div>

    <!-- Audio Element for Voice Messages -->
    <audio id="voicePlayer" style="display: none;"></audio>

    <script>
        // Global variables
        let socket = null;
        let currentUser = null;
        let chatUser = null;
        let chatUserId = null;
        let messages = [];
        let isLoadingMessages = false;
        let hasMoreMessages = true;
        let currentPage = 1;
        
        // WebRTC variables
        let peerConnection = null;
        let localStream = null;
        let remoteStream = null;
        let isCaller = false;
        let isInCall = false;
        let callStartTime = null;
        let callTimerInterval = null;
        let currentCallType = null;
        let currentCallId = null;
        let callTimeout = null;
        let pendingOffer = null; // Store incoming call offer
        
        // Voice recording variables
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let recordingTimer = null;
        let recordingStartTime = null;
        
        // Typing variables
        let typingTimeout = null;
        let isTyping = false;
        
        // DOM Content Loaded
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('ðŸš€ Chat page loaded');
            
            // Get chat user ID from URL
            await getChatUserIdFromURL();
            
            // Check authentication
            await checkAuth();
            
            // Load current user
            await loadCurrentUser();
            
            // Load chat user
            await loadChatUser();
            
            // Initialize socket connection
            initializeSocket();
            
            // Load messages
            await loadMessages();
            
            // Setup event listeners
            setupEventListeners();
            
            // Setup scroll listener for infinite scroll
            setupInfiniteScroll();
            
            console.log('âœ… Chat initialized successfully');
        });
        
        // Get chat user ID from URL
        async function getChatUserIdFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            chatUserId = urlParams.get('user');
            
            if (!chatUserId) {
                showNotification('User ID not found', 'error');
                setTimeout(() => {
                    window.location.href = '/messages.html';
                }, 2000);
                throw new Error('User ID not found');
            }
            
            console.log('ðŸ‘¤ Chat User ID:', chatUserId);
        }
        
        // Authentication check
        async function checkAuth() {
            const token = localStorage.getItem('token');
            if (!token) {
                window.location.href = '/login.html';
                throw new Error('Not authenticated');
            }
            
            try {
                const response = await fetch('/api/me', {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    localStorage.removeItem('token');
                    window.location.href = '/login.html';
                    throw new Error('Authentication failed');
                }
            } catch (error) {
                console.error('Auth check failed:', error);
                window.location.href = '/login.html';
                throw error;
            }
        }
        
        // Load current user
        async function loadCurrentUser() {
            try {
                const token = localStorage.getItem('token');
                const response = await fetch('/api/me', {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                if (data.success) {
                    currentUser = data.user;
                    console.log('ðŸ‘¤ Current user loaded:', currentUser.username);
                } else {
                    throw new Error('Failed to load user');
                }
            } catch (error) {
                console.error('Failed to load current user:', error);
                showNotification('Failed to load user data', 'error');
            }
        }
        
        // Load chat user
        async function loadChatUser() {
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`/api/user/${chatUserId}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    chatUser = data.user;
                    renderChatUserInfo(chatUser);
                    console.log('ðŸ‘¤ Chat user loaded:', chatUser.username);
                } else {
                    showNotification('User not found', 'error');
                    setTimeout(() => {
                        window.location.href = '/messages.html';
                    }, 2000);
                    throw new Error('User not found');
                }
            } catch (error) {
                console.error('Failed to load chat user:', error);
                showNotification('Failed to load user info', 'error');
                throw error;
            }
        }
        
        // Render chat user info
        function renderChatUserInfo(user) {
            // Update navigation
            document.getElementById('chatUserAvatar').src = user.avatar || 'https://via.placeholder.com/150';
            document.getElementById('chatUserName').textContent = user.nickname || user.username;
            document.getElementById('chatUserUniversity').textContent = user.university || 'No university';
            
            // Update status
            updateUserStatus(user.isOnline);
            
            // Update sidebar
            document.getElementById('sidebarUserAvatar').src = user.avatar || 'https://via.placeholder.com/150';
            document.getElementById('sidebarUserName').textContent = user.nickname || user.username;
            document.getElementById('sidebarUserUsername').textContent = `@${user.username}`;
            document.getElementById('sidebarUserUniversity').textContent = user.university || 'No university';
            document.getElementById('studyGroupText').textContent = user.studyGroup || 'Not specified';
            document.getElementById('sidebarUserPhone').textContent = user.phone || 'Not provided';
            document.getElementById('sidebarUserEmail').textContent = user.email || 'Not provided';
            
            // Update call UI
            document.getElementById('remoteUserName').textContent = user.nickname || user.username;
            document.getElementById('callerAvatar').src = user.avatar || 'https://via.placeholder.com/150';
            document.getElementById('callerName').textContent = user.nickname || user.username;
        }
        
        // Update user status
        function updateUserStatus(isOnline) {
            const statusClass = isOnline ? 'online' : 'offline';
            const statusText = isOnline ? 'Online' : 'Offline';
            const statusColor = isOnline ? 'green' : 'gray';
            
            // Update navigation status dot
            const chatStatus = document.getElementById('chatUserStatus');
            chatStatus.className = `status-dot ${statusClass}`;
            
            // Update sidebar status
            const sidebarStatus = document.getElementById('sidebarUserStatus');
            sidebarStatus.className = `status-dot ${statusClass}`;
            
            const statusTextEl = document.getElementById('sidebarUserStatusText');
            statusTextEl.innerHTML = `
                <span class="w-2 h-2 rounded-full mr-2 bg-${statusColor}-500"></span>
                <span>${statusText}</span>
            `;
            
            // Update call buttons state
            const callButtons = document.querySelectorAll('#videoCallBtn, #voiceCallBtn, #sidebarVideoCallBtn, #sidebarVoiceCallBtn');
            callButtons.forEach(btn => {
                btn.disabled = !isOnline;
                btn.title = isOnline ? '' : 'User is offline';
                btn.classList.toggle('opacity-50', !isOnline);
                btn.classList.toggle('cursor-not-allowed', !isOnline);
            });
            
            console.log(`ðŸ“Š User status updated: ${statusText}`);
        }
        
        // Initialize socket connection
        function initializeSocket() {
            const token = localStorage.getItem('token');
            
            // Connect to Socket.IO server
            socket = io({
                transports: ['websocket', 'polling'],
                reconnection: true,
                reconnectionAttempts: 5,
                reconnectionDelay: 1000
            });
            
            // Connection events
            socket.on('connect', () => {
                console.log('ðŸ”Œ Socket.IO connected:', socket.id);
                
                // Authenticate with token
                socket.emit('authenticate', token);
            });
            
            socket.on('connect_error', (error) => {
                console.error('âŒ Socket.IO connection error:', error);
                showNotification('Connection error. Trying to reconnect...', 'error');
            });
            
            socket.on('disconnect', (reason) => {
                console.log('ðŸ”Œ Socket.IO disconnected:', reason);
                if (reason === 'io server disconnect') {
                    socket.connect();
                }
            });
            
            socket.on('reconnecting', (attemptNumber) => {
                console.log(`ðŸ”„ Reconnecting attempt ${attemptNumber}`);
            });
            
            socket.on('reconnect', () => {
                console.log('âœ… Socket reconnected');
                showNotification('Reconnected to server', 'success');
            });
            
            // Authentication response
            socket.on('authenticated', (data) => {
                console.log('âœ… Socket authenticated successfully:', data);
                
                // Join chat room
                socket.emit('joinChat', {
                    userId: currentUser._id,
                    targetUserId: chatUserId
                });

                // Ask server for current online status (covers the case where user is already online
                // before we open this page).
                socket.emit('checkOnline', { userId: chatUserId });
                
                // Start activity ping
                setInterval(() => {
                    socket.emit('activityPing');
                }, 30000); // Every 30 seconds
            });

            // Online status response
            socket.on('onlineStatus', (data) => {
                const targetId = (data && data.userId) ? data.userId : data;
                if (targetId === chatUserId) {
                    updateUserStatus(!!data.isOnline);
                }
            });
            
            socket.on('authenticationError', (data) => {
                console.error('âŒ Socket authentication error:', data);
                showNotification('Authentication failed. Please login again.', 'error');
                setTimeout(() => {
                    window.location.href = '/login.html';
                }, 2000);
            });
            
            // Chat room joined
            socket.on('chatJoined', (data) => {
                console.log('âœ… Joined chat room:', data.roomName);
            });
            
            // New message received
            socket.on('newMessage', (message) => {
                console.log('ðŸ“¨ New message received:', message);

	                // Normalize ids (senderId/receiverId can be populated objects or plain strings)
	                const senderId = (message.senderId && message.senderId._id) ? message.senderId._id : message.senderId;
	                const receiverId = (message.receiverId && message.receiverId._id) ? message.receiverId._id : message.receiverId;
	                const me = currentUser?._id;

	                // Show messages for this chat in BOTH directions
	                const isIncoming = senderId === chatUserId && receiverId === me;
	                const isOutgoing = senderId === me && receiverId === chatUserId;

	                if (isIncoming || isOutgoing) {
	                    // Newest messages should appear at the bottom
	                    addMessageToUI(message, false);
	                }

	                if (isIncoming) {
	                    // Mark as read only for incoming messages
	                    socket.emit('markMessageRead', {
	                        messageId: message._id,
	                        readerId: me
	                    });

	                    // Play notification sound for incoming messages
	                    if (!document.hidden) {
	                        playNotificationSound();
	                    }
	                }
            });
            
	            // Message sent confirmation
	            socket.on('messageSent', (message) => {
	                console.log('âœ“ Message sent confirmation:', message._id);
	                // Reconcile optimistic message (replace temp id with real id)
	                if (message.clientTempId) {
	                    const tempEl = document.querySelector(`[data-message-id="${message.clientTempId}"]`);
	                    if (tempEl) {
	                        tempEl.dataset.messageId = message._id;
	                    }
	                }

	                // If for some reason the UI didn't render on newMessage, ensure it's visible
	                const senderId = (message.senderId && message.senderId._id) ? message.senderId._id : message.senderId;
	                const receiverId = (message.receiverId && message.receiverId._id) ? message.receiverId._id : message.receiverId;
	                const me = currentUser?._id;
	                const isOutgoing = senderId === me && receiverId === chatUserId;
	                if (isOutgoing) {
	                    const exists = document.querySelector(`[data-message-id="${message._id}"]`);
	                    if (!exists) addMessageToUI(message, false);
	                }
	            });
            
            // Message delivered
            socket.on('messageDelivered', (data) => {
                console.log('âœ“ Message delivered:', data.messageId);
                updateMessageStatus(data.messageId, 'delivered');
            });
            
            // Message read
            socket.on('messageRead', (data) => {
                console.log('âœ“ Message read:', data.messageId);
                updateMessageStatus(data.messageId, 'read');
            });
            
            // Message error
            socket.on('messageError', (data) => {
                console.error('âŒ Message error:', data);
                showNotification('Failed to send message: ' + data.error, 'error');
            });
            
            // Typing indicator
            socket.on('userTyping', (data) => {
                if (data.userId === chatUserId) {
                    if (data.isTyping) {
                        document.getElementById('typingText').textContent = `${chatUser.nickname} is typing...`;
                        document.getElementById('typingIndicator').classList.remove('hidden');
                    } else {
                        document.getElementById('typingIndicator').classList.add('hidden');
                    }
                }
            });
            
            // User status updates
            socket.on('userOnline', (data) => {
                if (data.userId === chatUserId) {
                    updateUserStatus(true);
                    showNotification(`${chatUser.nickname} is now online`, 'info');
                }
            });
            
            socket.on('userOffline', (data) => {
                if (data.userId === chatUserId) {
                    updateUserStatus(false);
                    showNotification(`${chatUser.nickname} is now offline`, 'warning');
                }
            });
            
            // Call signaling
            socket.on('callOffer', (data) => {
                console.log('ðŸ“ž Incoming call offer:', data);
                if (data.from === chatUserId && !isInCall) {
                    // Store the offer for when user accepts
                    pendingOffer = data.offer;
                    showIncomingCall(data);
                }
            });
            
            socket.on('callAnswer', async (data) => {
                console.log('âœ… Call answer received:', data);
                if (data.from === chatUserId) {
                    await handleCallAnswer(data);
                }
            });
            
            socket.on('iceCandidate', async (data) => {
                console.log('â„ï¸ ICE candidate received:', data);
                if (data.from === chatUserId) {
                    await handleIceCandidate(data);
                }
            });
            
            socket.on('callEnded', (data) => {
                console.log('ðŸ“ž Call ended:', data);
                if (data.from === chatUserId) {
                    endCall();
                    if (data.duration > 0) {
                        showNotification(`Call ended. Duration: ${formatDuration(data.duration)}`, 'info');
                    } else {
                        showNotification('Call ended', 'info');
                    }
                }
            });
            
            socket.on('callRejected', (data) => {
                console.log('âŒ Call rejected:', data);
                if (data.from === chatUserId) {
                    hideCallUI();
                    showNotification('Call rejected', 'warning');
                }
            });
            
            socket.on('callTimeout', (data) => {
                console.log('â° Call timeout:', data);
                if (data.to === currentUser._id) {
                    hideCallUI();
                    showNotification('Call timed out. No answer.', 'warning');
                }
            });
            
            socket.on('callError', (data) => {
                console.error('âŒ Call error:', data);
                showNotification('Call error: ' + data.error, 'error');
                hideCallUI();
            });
        }
        
        // Setup infinite scroll
        function setupInfiniteScroll() {
            const container = document.getElementById('messagesContainer');
            container.addEventListener('scroll', () => {
                if (container.scrollTop === 0 && !isLoadingMessages && hasMoreMessages) {
                    loadMoreMessages();
                }
            });
        }
        
        // Load messages from API
        async function loadMessages() {
            try {
                isLoadingMessages = true;
	            const container = document.getElementById('messagesContainer');
	            const loadingEl = document.getElementById('loadingIndicator');
                const token = localStorage.getItem('token');
                const response = await fetch(`/api/messages/${chatUserId}?page=${currentPage}&limit=50`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (data.success) {
	                if (currentPage === 1) {
                        messages = data.messages;
                        renderMessages(messages);
	                    
	                    // Hide loading indicator (if exists)
	                    if (loadingEl) loadingEl.style.display = 'none';
                        
                        // Scroll to bottom
                        setTimeout(scrollToBottom, 100);
                    } else {
                        // Append older messages at the top
	                    const oldScrollHeight = container ? container.scrollHeight : 0;
                        data.messages.forEach(message => {
                            messages.unshift(message);
                        });
                        renderMessages(messages);
                        
                        // Restore scroll position
	                    if (container) {
	                        const newScrollHeight = container.scrollHeight;
	                        container.scrollTop = newScrollHeight - oldScrollHeight;
	                    }
                    }
                    
                    hasMoreMessages = data.messages.length === 50;
                }
            } catch (error) {
                console.error('Failed to load messages:', error);
	            const loadingEl = document.getElementById('loadingIndicator');
	            if (currentPage === 1 && loadingEl) {
	                loadingEl.innerHTML = `
                        <p class="text-red-500">Failed to load messages</p>
                        <button onclick="loadMessages()" class="mt-2 px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700">
                            Retry
                        </button>
                    `;
                }
            } finally {
                isLoadingMessages = false;
            }
        }
        
        // Load more messages
        async function loadMoreMessages() {
            currentPage++;
            await loadMessages();
        }
        
        // Render messages
        function renderMessages(messages) {
            const container = document.getElementById('messagesContainer');
            
            if (!messages || messages.length === 0) {
                if (currentPage === 1) {
                    container.innerHTML = `
                        <div class="text-center py-8">
                            <i class="fas fa-comments text-4xl text-gray-300 mb-4"></i>
                            <h3 class="text-xl font-semibold text-gray-500">No messages yet</h3>
                            <p class="text-gray-400 mt-2">Send your first message to start the conversation</p>
                        </div>
                    `;
                }
                return;
            }
            
            if (currentPage === 1) {
                container.innerHTML = '';
            }
            
            // Group messages by date
            const groupedMessages = groupMessagesByDate(messages);
            
            // Render each group
            Object.keys(groupedMessages).forEach(date => {
                // Add date separator
                if (currentPage === 1 || container.querySelectorAll('.date-separator').length === 0) {
                    const dateSeparator = document.createElement('div');
                    dateSeparator.className = 'date-separator text-center my-4';
                    dateSeparator.innerHTML = `
                        <span class="bg-gray-200 text-gray-600 text-xs px-3 py-1 rounded-full">
                            ${formatDate(new Date(date))}
                        </span>
                    `;
                    container.prepend(dateSeparator);
                }
                
                // Render messages for this date
                groupedMessages[date].forEach(message => {
                    const messageElement = createMessageElement(message);
                    container.prepend(messageElement);
                });
            });
        }
        
        // Group messages by date
        function groupMessagesByDate(messages) {
            const groups = {};
            
            messages.forEach(message => {
                const date = new Date(message.createdAt).toDateString();
                if (!groups[date]) {
                    groups[date] = [];
                }
                groups[date].push(message);
            });
            
            return groups;
        }
        
        // Format date for display
        function formatDate(date) {
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            
            if (date.toDateString() === today.toDateString()) {
                return 'Today';
            } else if (date.toDateString() === yesterday.toDateString()) {
                return 'Yesterday';
            } else {
                return date.toLocaleDateString('en-US', { 
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
            }
        }
        
        // Format duration
        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Create message element
        function createMessageElement(message) {
            const isSent = message.senderId._id === currentUser._id || message.senderId === currentUser._id;
            const div = document.createElement('div');
            div.className = `flex ${isSent ? 'justify-end' : 'justify-start'} mb-2`;
            div.dataset.messageId = message._id;
            
            const time = new Date(message.createdAt).toLocaleTimeString([], { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
            
            let content = '';
            
            // Check media type
            if (message.mediaType === 'voice') {
                content = createVoiceMessageContent(message);
            } else if (message.mediaType === 'image') {
                content = createImageMessageContent(message);
            } else if (message.mediaType === 'video') {
                content = createVideoMessageContent(message);
            } else if (message.mediaType === 'audio') {
                content = createAudioMessageContent(message);
            } else if (message.mediaType === 'document' || message.mediaType === 'file') {
                content = createFileMessageContent(message);
            } else {
                content = createTextMessageContent(message);
            }
            
            // Status indicator
            let statusIcon = 'fa-check';
            if (isSent) {
                if (message.isRead) {
                    statusIcon = 'fa-check-double text-blue-500';
                } else if (message.isDelivered) {
                    statusIcon = 'fa-check-double';
                } else {
                    statusIcon = 'fa-check';
                }
            }
            
            div.innerHTML = `
                <div class="message-bubble ${isSent ? 'sent' : 'received'}">
                    ${!isSent ? `
                        <div class="flex items-center mb-1">
                            <span class="font-medium text-sm">${chatUser.nickname}</span>
                        </div>
                    ` : ''}
                    
                    ${content}
                    
                    <div class="message-time">
                        ${time}
                        ${isSent ? `
                            <span class="message-status">
                                <i class="fas ${statusIcon} ml-1"></i>
                            </span>
                        ` : ''}
                    </div>
                </div>
            `;
            
            return div;
        }
        
        // Create voice message content
        function createVoiceMessageContent(message) {
            const duration = message.mediaMetadata?.duration || '0:00';
            return `
                <div class="voice-message" onclick="playVoiceMessage('${message.mediaUrl}', this)">
                    <button class="play-pause-btn">
                        <i class="fas fa-play"></i>
                    </button>
                    <div class="voice-wave">
                        <div class="voice-bar"></div>
                        <div class="voice-bar"></div>
                        <div class="voice-bar"></div>
                        <div class="voice-bar"></div>
                        <div class="voice-bar"></div>
                    </div>
                    <span class="ml-2 text-xs">${duration}</span>
                </div>
            `;
        }
        
        // Create image message content
        function createImageMessageContent(message) {
            return `
                <div class="mb-2">
                    <img src="${message.mediaUrl}" 
                         alt="Image" 
                         class="max-w-full rounded-lg cursor-pointer"
                         onclick="viewImage('${message.mediaUrl}')">
                    ${message.text ? `<p class="mt-2">${message.text}</p>` : ''}
                </div>
            `;
        }
        
        // Create video message content
        function createVideoMessageContent(message) {
            return `
                <div class="mb-2">
                    <video src="${message.mediaUrl}" 
                           controls 
                           class="max-w-full rounded-lg"
                           poster="${message.mediaMetadata?.thumbnail || ''}">
                    </video>
                    ${message.text ? `<p class="mt-2">${message.text}</p>` : ''}
                </div>
            `;
        }
        
        // Create audio message content
        function createAudioMessageContent(message) {
            return `
                <div class="mb-2">
                    <audio src="${message.mediaUrl}" 
                           controls 
                           class="w-full">
                    </audio>
                    ${message.text ? `<p class="mt-2">${message.text}</p>` : ''}
                </div>
            `;
        }
        
        // Create file message content
        function createFileMessageContent(message) {
            const fileName = message.mediaMetadata?.fileName || 'File';
            const fileSize = message.mediaMetadata?.fileSize ? formatFileSize(message.mediaMetadata.fileSize) : '';
            
            return `
                <div class="file-message cursor-pointer" onclick="downloadFile('${message.mediaUrl}', '${fileName}')">
                    <div class="file-icon">
                        <i class="fas fa-file"></i>
                    </div>
                    <div class="file-info">
                        <div class="file-name">${fileName}</div>
                        <div class="file-size">${fileSize}</div>
                    </div>
                    <div class="ml-2">
                        <i class="fas fa-download text-gray-400"></i>
                    </div>
                </div>
                ${message.text ? `<p class="mt-2">${message.text}</p>` : ''}
            `;
        }
        
        // Create text message content
        function createTextMessageContent(message) {
            // Simple URL detection and linking
            const text = message.text || '';
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            const linkedText = text.replace(urlRegex, url => 
                `<a href="${url}" target="_blank" class="text-blue-500 hover:underline">${url}</a>`
            );
            
            return `<p>${linkedText}</p>`;
        }
        
        // Format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // Add message to UI
        function addMessageToUI(message, prepend = false) {
            const container = document.getElementById('messagesContainer');
            
            // Remove only the real "no messages" placeholder, not date separators.
            const noMsg = container.querySelector('[data-role="no-messages"]') || container.querySelector('#noMessagesPlaceholder');
            if (noMsg) {
                container.innerHTML = '';
            }
            
            const messageElement = createMessageElement(message);
            
            if (prepend) {
                container.prepend(messageElement);
            } else {
                container.appendChild(messageElement);
            }
            
            // Scroll to bottom if new message is from bottom
            if (!prepend) {
                scrollToBottom();
            }
        }
        
        // Update message status
        function updateMessageStatus(messageId, status) {
            const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageElement) {
                const statusIcon = messageElement.querySelector('.message-status i');
                if (statusIcon) {
                    if (status === 'delivered') {
                        statusIcon.className = 'fas fa-check-double';
                    } else if (status === 'read') {
                        statusIcon.className = 'fas fa-check-double text-blue-500';
                    }
                }
            }
        }
        
        // Send message
        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const messageText = input.value.trim();
            
            if (!messageText) return;
            
            try {
                // Disable send button
                const sendBtn = document.getElementById('sendButton');
                sendBtn.disabled = true;
                sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                
	                // Optimistic UI: show the message immediately
	                const tempId = `temp_${Date.now()}`;
	                addMessageToUI({
	                    _id: tempId,
	                    senderId: currentUser._id,
	                    receiverId: chatUserId,
	                    text: messageText,
	                    mediaUrl: '',
	                    mediaType: '',
	                    type: 'text',
	                    createdAt: new Date().toISOString(),
	                    isDelivered: false,
	                    isRead: false
	                }, false);
	                
	                // Send via Socket.IO for real-time (server will persist)
                socket.emit('privateMessage', {
                    senderId: currentUser._id,
                    receiverId: chatUserId,
                    text: messageText,
                    // IMPORTANT: do not use mediaType: 'text' (schema enum doesn't include it)
                    mediaType: '',
	                    type: 'text',
	                    clientTempId: tempId
                });
                
                // Clear input
                input.value = '';
                autoResize(input);
                
                // Re-enable send button
                setTimeout(() => {
                    sendBtn.disabled = false;
                    sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
                }, 1000);
                
                // Stop typing indicator
                stopTyping();
                
            } catch (error) {
                console.error('Failed to send message:', error);
                showNotification('Failed to send message', 'error');
            }
        }
        
        // Typing functions
        function startTyping() {
            if (!isTyping) {
                isTyping = true;
                socket.emit('typing', {
                    userId: chatUserId,
                    isTyping: true
                });
            }
            
            if (typingTimeout) {
                clearTimeout(typingTimeout);
            }
            
            typingTimeout = setTimeout(stopTyping, 2000);
        }
        
        function stopTyping() {
            if (isTyping) {
                isTyping = false;
                socket.emit('typing', {
                    userId: chatUserId,
                    isTyping: false
                });
            }
            
            if (typingTimeout) {
                clearTimeout(typingTimeout);
                typingTimeout = null;
            }
        }
        
        // Handle key down events
        function handleKeyDown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }
        
        // Auto-resize textarea
        function autoResize(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
        }
        
        // Scroll to bottom of messages
        function scrollToBottom() {
            const container = document.getElementById('messagesContainer');
            container.scrollTop = container.scrollHeight;
        }
        
        // Setup event listeners
        function setupEventListeners() {
            // Enable/disable send button based on input
            const input = document.getElementById('messageInput');
            const sendBtn = document.getElementById('sendButton');
            
            input.addEventListener('input', () => {
                sendBtn.disabled = !input.value.trim();
            });
            
            // Page visibility change
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden && socket) {
                    // Re-authenticate if needed
                    const token = localStorage.getItem('token');
                    socket.emit('authenticate', token);
                }
            });
            
            // Online/offline detection
            window.addEventListener('online', () => {
                showNotification('You are back online', 'success');
                if (socket && !socket.connected) {
                    socket.connect();
                }
            });
            
            window.addEventListener('offline', () => {
                showNotification('You are offline', 'warning');
            });
        }
        
        // WebRTC Call Functions
        
        // Start video call
        async function startVideoCall() {
            if (!chatUser || !chatUser.isOnline) {
                showNotification(`${chatUser?.nickname || 'User'} is offline`, 'warning');
                return;
            }
            
            if (isInCall) {
                showNotification('You are already in a call', 'warning');
                return;
            }
            
            try {
                isCaller = true;
                currentCallType = 'video';
                showConnectingModal('Calling...', 'Waiting for answer');
                
                // Get local media stream
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        frameRate: { ideal: 30 }
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                // Create peer connection
                await createPeerConnection();
                
                // Add local tracks
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
                
                // Create offer
                const offer = await peerConnection.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: true,
                    voiceActivityDetection: true
                });
                
                await peerConnection.setLocalDescription(offer);
                
                // Send offer to other user
                socket.emit('callOffer', {
                    to: chatUserId,
                    offer: offer,
                    type: 'video'
                });
                
                // Set call timeout (30 seconds)
                callTimeout = setTimeout(() => {
                    if (!isInCall) {
                        socket.emit('callTimeout', {
                            to: chatUserId
                        });
                        hideCallUI();
                        showNotification('Call timed out. No answer.', 'warning');
                    }
                }, 30000);
                
            } catch (error) {
                console.error('Error starting video call:', error);
                endCall();
                
                if (error.name === 'NotAllowedError') {
                    showNotification('Camera/microphone access is required for video calls', 'error');
                } else if (error.name === 'NotFoundError') {
                    showNotification('No camera/microphone found', 'error');
                } else {
                    showNotification('Failed to start video call: ' + error.message, 'error');
                }
            }
        }
        
        // Start voice call
        async function startVoiceCall() {
            if (!chatUser || !chatUser.isOnline) {
                showNotification(`${chatUser?.nickname || 'User'} is offline`, 'warning');
                return;
            }
            
            if (isInCall) {
                showNotification('You are already in a call', 'warning');
                return;
            }
            
            try {
                isCaller = true;
                currentCallType = 'audio';
                showConnectingModal('Calling...', 'Waiting for answer');
                
                // Get audio only
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: false,
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        channelCount: 1
                    }
                });
                
                // Hide video containers for audio call
                document.querySelectorAll('.video-container').forEach(container => {
                    container.style.display = 'none';
                });
                
                // Create peer connection
                await createPeerConnection();
                
                // Add audio track
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
                
                // Create offer
                const offer = await peerConnection.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: false,
                    voiceActivityDetection: true
                });
                
                await peerConnection.setLocalDescription(offer);
                
                // Send offer
                socket.emit('callOffer', {
                    to: chatUserId,
                    offer: offer,
                    type: 'audio'
                });
                
                // Set call timeout (30 seconds)
                callTimeout = setTimeout(() => {
                    if (!isInCall) {
                        socket.emit('callTimeout', {
                            to: chatUserId
                        });
                        hideCallUI();
                        showNotification('Call timed out. No answer.', 'warning');
                    }
                }, 30000);
                
            } catch (error) {
                console.error('Error starting voice call:', error);
                endCall();
                
                if (error.name === 'NotAllowedError') {
                    showNotification('Microphone access is required for voice calls', 'error');
                } else if (error.name === 'NotFoundError') {
                    showNotification('No microphone found', 'error');
                } else {
                    showNotification('Failed to start voice call: ' + error.message, 'error');
                }
            }
        }
        
        // Create peer connection
        async function createPeerConnection() {
            const configuration = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' },
                    { urls: 'stun:stun4.l.google.com:19302' }
                ],
                iceCandidatePoolSize: 10,
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require'
            };
            
            peerConnection = new RTCPeerConnection(configuration);
            
            // Handle remote stream
            peerConnection.ontrack = (event) => {
                remoteStream = event.streams[0];
                const remoteVideo = document.getElementById('remoteVideo');
                remoteVideo.srcObject = remoteStream;
                
                // For audio calls, we might want to show something else
                if (currentCallType === 'audio') {
                    document.getElementById('remoteUserName').textContent = `${chatUser.nickname} (Audio Call)`;
                }
            };
            
            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('iceCandidate', {
                        to: chatUserId,
                        candidate: event.candidate
                    });
                }
            };
            
            // Handle connection state
            peerConnection.onconnectionstatechange = () => {
                console.log('WebRTC connection state:', peerConnection.connectionState);
                
                switch(peerConnection.connectionState) {
                    case 'connected':
                        if (!callStartTime) {
                            callStartTime = Date.now();
                            updateCallTimer();
                            callTimerInterval = setInterval(updateCallTimer, 1000);
                        }
                        showNotification('Call connected', 'success');
                        break;
                    case 'disconnected':
                    case 'failed':
                        endCall();
                        showNotification('Call disconnected', 'error');
                        break;
                    case 'closed':
                        console.log('WebRTC connection closed');
                        break;
                }
            };
            
            // Handle ICE connection state
            peerConnection.oniceconnectionstatechange = () => {
                console.log('ICE connection state:', peerConnection.iceConnectionState);
                
                if (peerConnection.iceConnectionState === 'failed' ||
                    peerConnection.iceConnectionState === 'disconnected') {
                    // Try to restart ICE
                    setTimeout(() => {
                        if (peerConnection.iceConnectionState !== 'connected' &&
                            peerConnection.iceConnectionState !== 'completed') {
                            endCall();
                            showNotification('Connection lost', 'error');
                        }
                    }, 1000);
                }
            };
            
            // Handle signaling state
            peerConnection.onsignalingstatechange = () => {
                console.log('Signaling state:', peerConnection.signalingState);
            };
        }
        
        // Show connecting modal
        function showConnectingModal(title, subtext) {
            document.getElementById('connectingText').textContent = title;
            document.getElementById('connectingSubtext').textContent = subtext;
            document.getElementById('callConnectingModal').classList.remove('hidden');
        }
        
        // Hide connecting modal
        function hideConnectingModal() {
            document.getElementById('callConnectingModal').classList.add('hidden');
        }
        
        // Show incoming call modal
        function showIncomingCall(data) {
            currentCallType = data.type;
            currentCallId = data.callerInfo?.callId;
            
            document.getElementById('callType').textContent = 
                data.type === 'video' ? 'Video Call' : 'Voice Call';
            
            // Update caller info if available
            if (data.callerInfo) {
                document.getElementById('callerName').textContent = data.callerInfo.nickname || 'Unknown';
                if (data.callerInfo.avatar) {
                    document.getElementById('callerAvatar').src = data.callerInfo.avatar;
                }
            }
            
            document.getElementById('incomingCallModal').classList.remove('hidden');
            
            // Play ringtone
            playRingtone();
            
            // Auto reject after 45 seconds
            setTimeout(() => {
                if (!document.getElementById('incomingCallModal').classList.contains('hidden')) {
                    rejectCall();
                }
            }, 45000);
        }
        
        // Accept incoming call
        async function acceptCall() {
            try {
                // Stop ringtone
                stopRingtone();
                
                document.getElementById('incomingCallModal').classList.add('hidden');
                isCaller = false;
                showCallUI();
                
                // Get media based on call type
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: currentCallType === 'video',
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                // Show/hide video containers
                if (currentCallType === 'video') {
                    const localVideo = document.getElementById('localVideo');
                    localVideo.srcObject = localStream;
                } else {
                    document.querySelectorAll('.video-container').forEach(container => {
                        container.style.display = 'none';
                    });
                }
                
                // Create peer connection
                await createPeerConnection();
                
                // Add local tracks
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
                
                // Set remote description from stored offer
                if (pendingOffer) {
                    const offer = new RTCSessionDescription(pendingOffer);
                    await peerConnection.setRemoteDescription(offer);
                    pendingOffer = null; // Clear after use
                } else {
                    throw new Error('No offer available');
                }
                
                // Create and send answer
                const answer = await peerConnection.createAnswer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: currentCallType === 'video'
                });
                await peerConnection.setLocalDescription(answer);
                
                socket.emit('callAnswer', {
                    to: chatUserId,
                    answer: answer,
                    callId: currentCallId
                });
                
                showNotification('Call accepted', 'success');
                
            } catch (error) {
                console.error('Error accepting call:', error);
                endCall();
                showNotification('Failed to accept call: ' + error.message, 'error');
            }
        }
        
        // Reject incoming call
        function rejectCall() {
            // Stop ringtone
            stopRingtone();
            
            document.getElementById('incomingCallModal').classList.add('hidden');
            
            // Clear pending offer
            pendingOffer = null;
            
            socket.emit('callRejected', {
                to: chatUserId,
                callId: currentCallId
            });
            
            showNotification('Call rejected', 'info');
        }
        
        // Cancel outgoing call
        function cancelCall() {
            hideConnectingModal();
            endCall();
            showNotification('Call cancelled', 'info');
        }
        
        // Handle call answer
        async function handleCallAnswer(data) {
            try {
                if (!peerConnection) return;
                
                hideConnectingModal();
                
                const answer = new RTCSessionDescription(data.answer);
                await peerConnection.setRemoteDescription(answer);
                
                // Clear call timeout
                if (callTimeout) {
                    clearTimeout(callTimeout);
                    callTimeout = null;
                }
                
                showCallUI();
                
            } catch (error) {
                console.error('Error handling call answer:', error);
                endCall();
            }
        }
        
        // Handle ICE candidate
        async function handleIceCandidate(data) {
            try {
                if (!peerConnection) return;
                
                const candidate = new RTCIceCandidate(data.candidate);
                await peerConnection.addIceCandidate(candidate);
                
            } catch (error) {
                console.error('Error adding ICE candidate:', error);
            }
        }
        
        // Show call UI
        function showCallUI() {
            isInCall = true;
            document.getElementById('callContainer').style.display = 'flex';
            
            // Reset video containers for video calls
            if (currentCallType === 'video') {
                document.querySelectorAll('.video-container').forEach(container => {
                    container.style.display = 'block';
                });
            }
            
            // Start call timer
            callStartTime = Date.now();
            updateCallTimer();
            callTimerInterval = setInterval(updateCallTimer, 1000);
            
            // Show appropriate title
            const callTitle = currentCallType === 'video' ? 'Video Call' : 'Voice Call';
            document.title = `${callTitle} with ${chatUser.nickname} - UniConnect`;
        }
        
        // Update call timer
        function updateCallTimer() {
            if (!callStartTime) return;
            
            const duration = Math.floor((Date.now() - callStartTime) / 1000);
            const minutes = Math.floor(duration / 60);
            const seconds = duration % 60;
            
            document.getElementById('callTimer').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // End call
        function endCall() {
            if (isInCall) {
                // Calculate call duration
                const duration = callStartTime ? Math.floor((Date.now() - callStartTime) / 1000) : 0;
                
                // Notify other user
                socket.emit('callEnded', {
                    to: chatUserId,
                    duration: duration,
                    callId: currentCallId
                });
                
                // Add call duration message to chat if call lasted more than 5 seconds
                if (duration > 5) {
                    const durationText = `Call ended. Duration: ${formatDuration(duration)}`;
                    socket.emit('privateMessage', {
                        senderId: currentUser._id,
                        receiverId: chatUserId,
                        text: durationText,
                        type: 'system'
                    });
                }
            }
            
            hideCallUI();
        }
        
        // Hide call UI
        function hideCallUI() {
            document.getElementById('callContainer').style.display = 'none';
            document.getElementById('incomingCallModal').classList.add('hidden');
            document.getElementById('callConnectingModal').classList.add('hidden');
            
            isInCall = false;
            isCaller = false;
            
            // Clear pending offer
            pendingOffer = null;
            
            // Stop call timer
            if (callTimerInterval) {
                clearInterval(callTimerInterval);
                callTimerInterval = null;
            }
            
            // Clear call timeout
            if (callTimeout) {
                clearTimeout(callTimeout);
                callTimeout = null;
            }
            
            // Stop and clean up media streams
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    track.stop();
                    track.enabled = false;
                });
                localStream = null;
            }
            
            if (remoteStream) {
                remoteStream.getTracks().forEach(track => track.stop());
                remoteStream = null;
            }
            
            // Close peer connection
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            // Reset video elements
            document.getElementById('localVideo').srcObject = null;
            document.getElementById('remoteVideo').srcObject = null;
            
            // Show video containers
            document.querySelectorAll('.video-container').forEach(container => {
                container.style.display = 'block';
            });
            
            // Reset title
            document.title = `Chat with ${chatUser.nickname} - UniConnect`;
            
            // Stop any playing sounds
            stopRingtone();
        }
        
        // Toggle audio
        function toggleAudio() {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                if (audioTrack) {
                    audioTrack.enabled = !audioTrack.enabled;
                    const btn = document.getElementById('toggleAudioBtn');
                    btn.classList.toggle('active');
                    btn.classList.toggle('inactive');
                    btn.innerHTML = audioTrack.enabled ? 
                        '<i class="fas fa-microphone"></i>' : 
                        '<i class="fas fa-microphone-slash"></i>';
                }
            }
        }
        
        // Toggle video
        function toggleVideo() {
            if (localStream) {
                const videoTrack = localStream.getVideoTracks()[0];
                if (videoTrack) {
                    videoTrack.enabled = !videoTrack.enabled;
                    const btn = document.getElementById('toggleVideoBtn');
                    btn.classList.toggle('active');
                    btn.classList.toggle('inactive');
                    btn.innerHTML = videoTrack.enabled ? 
                        '<i class="fas fa-video"></i>' : 
                        '<i class="fas fa-video-slash"></i>';
                }
            }
        }
        
        // Play ringtone
        function playRingtone() {
            // Create a simple ringtone using Web Audio API
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                oscillator.start();
                
                // Store for later stopping
                window.ringtone = { audioContext, oscillator, gainNode };
                
                // Repeat every 2 seconds
                window.ringtoneInterval = setInterval(() => {
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                }, 2000);
                
            } catch (error) {
                console.error('Error playing ringtone:', error);
            }
        }
        
        // Stop ringtone
        function stopRingtone() {
            if (window.ringtone) {
                try {
                    window.ringtone.oscillator.stop();
                    window.ringtone.audioContext.close();
                } catch (error) {
                    console.error('Error stopping ringtone:', error);
                }
                window.ringtone = null;
            }
            
            if (window.ringtoneInterval) {
                clearInterval(window.ringtoneInterval);
                window.ringtoneInterval = null;
            }
        }
        
        // Play notification sound
        function playNotificationSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 1000;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.1);
                
            } catch (error) {
                console.error('Error playing notification sound:', error);
            }
        }
        
        // Voice recording functions
        async function startVoiceRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 44100
                    }
                });
                
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus',
                    audioBitsPerSecond: 128000
                });
                
                audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    await sendVoiceMessage(audioBlob);
                    
                    // Stop all tracks
                    stream.getTracks().forEach(track => track.stop());
                };
                
                mediaRecorder.onerror = (event) => {
                    console.error('MediaRecorder error:', event);
                    showNotification('Recording error', 'error');
                    stopRecording();
                };
                
                mediaRecorder.start(100); // Collect data every 100ms
                isRecording = true;
                recordingStartTime = Date.now();
                
                // Show recording indicator
                document.getElementById('recordingIndicator').classList.remove('hidden');
                updateRecordingTimer();
                recordingTimer = setInterval(updateRecordingTimer, 1000);
                
                // Auto-stop after 2 minutes
                setTimeout(() => {
                    if (isRecording) {
                        stopRecording();
                    }
                }, 120000);
                
            } catch (error) {
                console.error('Error starting voice recording:', error);
                if (error.name === 'NotAllowedError') {
                    showNotification('Microphone access required for voice recording', 'error');
                } else {
                    showNotification('Failed to start recording', 'error');
                }
            }
        }
        
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                
                document.getElementById('recordingIndicator').classList.add('hidden');
                
                if (recordingTimer) {
                    clearInterval(recordingTimer);
                    recordingTimer = null;
                }
            }
        }
        
        function updateRecordingTimer() {
            if (!recordingStartTime) return;
            
            const duration = Math.floor((Date.now() - recordingStartTime) / 1000);
            const minutes = Math.floor(duration / 60);
            const seconds = duration % 60;
            
            document.getElementById('recordingTime').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        async function sendVoiceMessage(audioBlob) {
            try {
                const formData = new FormData();
                formData.append('audio', audioBlob, `voice_${Date.now()}.webm`);
                formData.append('receiverId', chatUserId);
                
                const token = localStorage.getItem('token');
                const response = await fetch('/api/messages/voice', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    },
                    body: formData
                });
                
                const data = await response.json();
                if (data.success) {
                    showNotification('Voice message sent', 'success');
                } else {
                    showNotification('Failed to send voice message', 'error');
                }
            } catch (error) {
                console.error('Error sending voice message:', error);
                showNotification('Failed to send voice message', 'error');
            }
        }
        
        // Play voice message
        function playVoiceMessage(url, element) {
            const audio = new Audio(url);
            const playBtn = element.querySelector('.play-pause-btn i');
            
            audio.onplay = () => {
                playBtn.className = 'fas fa-pause';
                element.classList.add('playing');
            };
            
            audio.onpause = () => {
                playBtn.className = 'fas fa-play';
                element.classList.remove('playing');
            };
            
            audio.onended = () => {
                playBtn.className = 'fas fa-play';
                element.classList.remove('playing');
            };
            
            if (audio.paused) {
                audio.play();
            } else {
                audio.pause();
            }
        }
        
        // File attachment functions
        function attachFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '*/*';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    sendFileMessage(file);
                }
            };
            input.click();
        }
        
        function attachImage() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.capture = 'environment';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    sendFileMessage(file);
                }
            };
            input.click();
        }
        
        function attachVideo() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'video/*';
            input.capture = 'environment';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    sendFileMessage(file);
                }
            };
            input.click();
        }
        
        async function sendFileMessage(file) {
            try {
                const formData = new FormData();
                formData.append('file', file);
                formData.append('receiverId', chatUserId);
                
                // Add text if available
                const textInput = document.getElementById('messageInput');
                if (textInput.value.trim()) {
                    formData.append('text', textInput.value.trim());
                    textInput.value = '';
                    autoResize(textInput);
                }
                
                const token = localStorage.getItem('token');
                const response = await fetch('/api/messages/file', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    },
                    body: formData
                });
                
                const data = await response.json();
                if (data.success) {
                    showNotification('File sent successfully', 'success');
                } else {
                    showNotification('Failed to send file', 'error');
                }
            } catch (error) {
                console.error('Error sending file:', error);
                showNotification('Failed to send file', 'error');
            }
        }
        
        // Download file
        function downloadFile(url, fileName) {
            const link = document.createElement('a');
            link.href = url;
            link.download = fileName;
            link.target = '_blank';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // View image in full screen
        function viewImage(url) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-90 z-50 flex items-center justify-center';
            modal.innerHTML = `
                <div class="relative max-w-4xl max-h-4xl">
                    <img src="${url}" class="max-w-full max-h-screen">
                    <button onclick="this.parentElement.parentElement.remove()" 
                            class="absolute top-4 right-4 text-white text-2xl bg-black bg-opacity-50 rounded-full w-10 h-10 flex items-center justify-center">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Close on escape key
            const closeModal = (e) => {
                if (e.key === 'Escape') {
                    modal.remove();
                    document.removeEventListener('keydown', closeModal);
                }
            };
            document.addEventListener('keydown', closeModal);
            
            // Close on click outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                    document.removeEventListener('keydown', closeModal);
                }
            });
        }
        
        // Toggle user info sidebar
        function toggleUserInfo() {
            const sidebar = document.getElementById('userInfoSidebar');
            sidebar.classList.toggle('hidden');
        }
        
        // View user profile
        function viewUserProfile() {
            if (chatUserId) {
                window.location.href = `/profile.html?user=${chatUserId}`;
            }
        }
        
        // Show notification
        function showNotification(message, type = 'info') {
            const toast = document.getElementById('notificationToast');
            const text = document.getElementById('notificationText');
            
            // Set icon based on type
            let icon = 'info-circle';
            let bgColor = 'bg-gray-800';
            
            switch(type) {
                case 'success':
                    icon = 'check-circle';
                    bgColor = 'bg-green-600';
                    break;
                case 'error':
                    icon = 'exclamation-circle';
                    bgColor = 'bg-red-600';
                    break;
                case 'warning':
                    icon = 'exclamation-triangle';
                    bgColor = 'bg-yellow-600';
                    break;
            }
            
            text.innerHTML = `<i class="fas fa-${icon} mr-2"></i> ${message}`;
            toast.className = `fixed top-4 right-4 ${bgColor} text-white px-4 py-3 rounded-lg shadow-lg z-50 transform transition-transform duration-300`;
            
            // Show
            setTimeout(() => {
                toast.classList.remove('translate-x-full');
            }, 10);
            
            // Hide after 3 seconds
            setTimeout(() => {
                toast.classList.add('translate-x-full');
            }, 3000);
        }
        
        // Check user online status
        async function checkUserOnlineStatus() {
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`/api/user/${chatUserId}/status`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                if (data.success) {
                    updateUserStatus(data.isOnline);
                }
            } catch (error) {
                console.error('Error checking user status:', error);
            }
        }
        
        // Periodically check online status (every 30 seconds)
        setInterval(checkUserOnlineStatus, 30000);
        
        // Test function
        window.testConnection = async () => {
            console.log('ðŸ§ª Testing connection...');
            console.log('Current User:', currentUser);
            console.log('Chat User:', chatUser);
            console.log('Socket Connected:', socket?.connected);
            console.log('Socket ID:', socket?.id);
            
            // Check online status via API
            await checkUserOnlineStatus();
            
            // Check if we can send a test message
            socket.emit('privateMessage', {
                senderId: currentUser._id,
                receiverId: chatUserId,
                text: 'Test message',
                type: 'text'
            });
            
            showNotification('Test message sent', 'success');
        };
        
        // Export functions for debugging
        window.debug = {
            socket,
            currentUser,
            chatUser,
            messages,
            peerConnection,
            localStream,
            remoteStream
        };
    </script>
</body>
</html>