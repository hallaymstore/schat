<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Group - UniConnect</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://unpkg.com/livekit-client/dist/livekit-client.umd.min.js"></script>

    <style>
        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .message-bubble {
            border-radius: 20px;
            max-width: 70%;
        }
        .message-bubble.sent {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin-left: auto;
        }
        .message-bubble.received {
            background: #f1f5f9;
            color: #334155;
        }
        .member-avatar {
            transition: transform 0.3s ease;
        }
        .member-avatar:hover {
            transform: scale(1.1);
        }
    </style>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">

<style id="glassTheme">
  :root{
    --glass-bg: rgba(255,255,255,.52);
    --glass-brd: rgba(255,255,255,.30);
    --muted: rgba(15,23,42,.74);
    --muted2: rgba(15,23,42,.56);
    --grid: rgba(15,23,42,.06);
    --ring: rgba(99,102,241,.40);
    --shadow: rgba(0,0,0,.18);
  }
  html.dark{
    --glass-bg: rgba(2,6,23,.56);
    --glass-brd: rgba(148,163,184,.16);
    --muted: rgba(226,232,240,.78);
    --muted2: rgba(226,232,240,.55);
    --grid: rgba(148,163,184,.08);
    --ring: rgba(236,72,153,.30);
    --shadow: rgba(0,0,0,.45);
  }

  html, body{
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial !important;
  }

  body{
    background:
      radial-gradient(1200px 600px at 12% 12%, rgba(99,102,241,.30), transparent 60%),
      radial-gradient(900px 520px at 88% 18%, rgba(236,72,153,.22), transparent 60%),
      radial-gradient(1000px 700px at 50% 92%, rgba(34,197,94,.18), transparent 60%),
      linear-gradient(180deg, rgba(248,250,252,1), rgba(241,245,249,1)) !important;
    background-attachment: fixed !important;
    color: rgb(15 23 42);
  }
  html.dark body{
    background:
      radial-gradient(1200px 600px at 12% 12%, rgba(99,102,241,.20), transparent 60%),
      radial-gradient(900px 520px at 88% 18%, rgba(236,72,153,.16), transparent 60%),
      radial-gradient(1000px 700px at 50% 92%, rgba(34,197,94,.12), transparent 60%),
      linear-gradient(180deg, rgba(2,6,23,1), rgba(15,23,42,1)) !important;
    color: rgb(226 232 240);
  }

  /* Subtle grid overlay */
  body:before{
    content:"";
    position: fixed;
    inset: 0;
    pointer-events:none;
    z-index: -1;
    background-image: linear-gradient(to right, var(--grid) 1px, transparent 1px),
                      linear-gradient(to bottom, var(--grid) 1px, transparent 1px);
    background-size: 70px 70px;
    mask-image: radial-gradient(closest-side at 50% 35%, black 0%, transparent 70%);
    opacity: .85;
  }

  /* Generic glass upgrade: cards, panels, modals, headers, sidebars */
  .glass, .card, .panel, .container, .box, .modal-content,
  header, nav, main, section, aside, footer,
  [class*="card"], [class*="panel"], [class*="sidebar"], [class*="header"], [class*="content"]{
    backdrop-filter: blur(18px);
    -webkit-backdrop-filter: blur(18px);
  }

  /* Make many common blocks glassy without breaking layout */
  header, nav{
    background: var(--glass-bg) !important;
    border-bottom: 1px solid var(--glass-brd) !important;
    box-shadow: 0 18px 55px var(--shadow) !important;
  }

  /* If there is a main wrapper, upgrade it */
  .main, .main-content, #main, #content, .content, .group-container, .group-page, .group-card{
    background: var(--glass-bg) !important;
    border: 1px solid var(--glass-brd) !important;
    border-radius: 22px;
    box-shadow: 0 22px 70px var(--shadow) !important;
  }

  /* Buttons */
  button, .btn, [role="button"], input[type="submit"]{
    border-radius: 14px !important;
  }
  .btn-primary, button.primary, .primary-btn{
    background: linear-gradient(135deg, rgba(99,102,241,1), rgba(236,72,153,1)) !important;
    color: white !important;
    border: 1px solid rgba(255,255,255,.18) !important;
  }
  .btn-primary:hover, button.primary:hover, .primary-btn:hover{ filter: brightness(1.05); }

  /* Inputs */
  input, textarea, select{
    background: rgba(255,255,255,.38) !important;
    border: 1px solid rgba(255,255,255,.28) !important;
    color: rgb(15 23 42) !important;
  }
  html.dark input, html.dark textarea, html.dark select{
    background: rgba(2,6,23,.32) !important;
    border: 1px solid rgba(148,163,184,.18) !important;
    color: rgb(226 232 240) !important;
  }
  input:focus, textarea:focus, select:focus{
    outline: none !important;
    box-shadow: 0 0 0 5px var(--ring) !important;
    border-color: transparent !important;
  }

  /* Text helpers if present */
  .muted{ color: var(--muted) !important; }
  .muted2{ color: var(--muted2) !important; }

  /* Scrollbar */
  ::-webkit-scrollbar{ width: 10px; height:10px; }
  ::-webkit-scrollbar-thumb{ background: rgba(148,163,184,.28); border-radius: 999px; }
  ::-webkit-scrollbar-track{ background: transparent; }

  /* Theme floating button */
  #themeFab{
    position: fixed;
    right: 18px;
    top: 88px;
    z-index: 9999;
    background: var(--glass-bg);
    border: 1px solid var(--glass-brd);
    box-shadow: 0 18px 55px var(--shadow);
    backdrop-filter: blur(18px);
    -webkit-backdrop-filter: blur(18px);
    border-radius: 16px;
    padding: 10px 12px;
    font-weight: 800;
    font-size: 13px;
    color: var(--muted);
    display: flex;
    gap: 10px;
    align-items: center;
    cursor: pointer;
    user-select: none;
  }
  #themeFab i{ opacity: .9; }
</style>
<script>
  (function(){
    const key='theme';
    const saved=localStorage.getItem(key);
    const prefers=window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    const mode=saved || (prefers?'dark':'light');
    if(mode==='dark') document.documentElement.classList.add('dark');
  })();
</script>

<style id="mobileSafe">
  *{box-sizing:border-box}
  html,body{width:100%;overflow-x:hidden}
  img,video,canvas,svg{max-width:100%;height:auto}
  a,button,span,p,h1,h2,h3,h4,h5,h6,div{overflow-wrap:anywhere;word-break:break-word}
  .container{max-width:100% !important}
  button, a{ -webkit-tap-highlight-color: transparent; }
  @media (max-width: 640px){
    .container{padding-left:12px!important;padding-right:12px!important}
    main.container{padding-top:14px!important;padding-bottom:18px!important}
    h1{font-size:1.25rem!important;line-height:1.25!important}
    .text-3xl{font-size:1.65rem!important;line-height:1.2!important}
    .text-2xl{font-size:1.35rem!important;line-height:1.25!important}
    .text-xl{font-size:1.15rem!important}
    .h-16{height:auto!important;min-height:64px}
    nav .space-x-4, nav .space-x-3{gap:.25rem!important}
    nav .space-x-4>*, nav .space-x-3>*{margin-left:0!important}
    #livePlayerWrap video{max-height:45vh!important}
    .message-bubble{max-width:88%!important}
    /* Side panels as drawers */
    #infoPanel, #userInfoSidebar{
      position:fixed !important;
      top:64px; right:0; bottom:0;
      width:min(92vw, 380px) !important;
      z-index:60;
      transform:translateX(105%);
      transition:transform .25s ease;
      display:block !important;
    }

    /* Call overlay mobile */

    /* Ensure overlay panels are above video */
    #groupCallOverlay{ position: fixed !important; inset: 0 !important; z-index: 2147483600 !important; }
    #groupIncomingBox{ z-index: 2147483605 !important; }
    #callMoreMenu{ z-index: 2147483640 !important; }
    #attendancePanel{ z-index: 2147483635 !important; }
    #drawerOverlay.show{ z-index: 2147483590 !important; }

    #studentsGrid{ grid-template-columns: repeat(1, minmax(0, 1fr)) !important; }
    @media (orientation: landscape){
      #studentsGrid{ grid-template-columns: repeat(2, minmax(0, 1fr)) !important; }
      #teacherStage{ max-height: 52vh; }
    }
    #groupCallOverlay .p-4{ padding: 12px !important; }
    #callMoreMenu{ width: min(86vw, 320px) !important; position: fixed !important; right: 12px !important; top: 84px !important; z-index: 2147483640 !important; }
    #groupActionsMenu{ z-index: 2147483640 !important; }
    #attendancePanel{ position: fixed !important; right: 12px !important; top: 84px !important; bottom: 12px !important; z-index: 2147483630 !important; }
    .ctrl-active{ background: rgba(34,197,94,.18) !important; box-shadow: 0 0 0 3px rgba(34,197,94,.25) !important; }
    .ctrl-off{ background: rgba(239,68,68,.18) !important; box-shadow: 0 0 0 3px rgba(239,68,68,.20) !important; }
  }
  #infoPanel.open, #userInfoSidebar.open{ transform:translateX(0); }
  #drawerOverlay{ display:none; }
  #drawerOverlay.show{
    display:block;
    position:fixed;
    inset:0;
    z-index:55;
    background:rgba(0,0,0,.45);
    backdrop-filter: blur(4px);
  }
</style>
<script id="mobileDrawerScript">
(function(){
  function qs(id){ return document.getElementById(id); }
  function closePanel(){
    const panel = qs('infoPanel') || qs('userInfoSidebar');
    const ov = qs('drawerOverlay');
    if(panel) panel.classList.remove('open');
    if(ov) ov.classList.remove('show');
    document.body.style.overflow = '';
  }
  function openPanel(){
    const panel = qs('infoPanel') || qs('userInfoSidebar');
    const ov = qs('drawerOverlay');
    if(panel) panel.classList.add('open');
    if(ov) ov.classList.add('show');
    document.body.style.overflow = 'hidden';
  }
  window.__drawer = {openPanel, closePanel};
  document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closePanel(); });
  document.addEventListener('click', (e)=>{
    const ov = qs('drawerOverlay');
    if(ov && e.target === ov) closePanel();
  });
})();
</script>

<style id="hallaymBrand">
  /* HALLAYM edu brand (teal + gold, glassy) */
  :root{
    --h-teal-1: #0ea5a7;
    --h-teal-2: #0b7f86;
    --h-deep: #06181a;
    --h-glass: rgba(255,255,255,.14);
    --h-glass2: rgba(255,255,255,.10);
    --h-brd: rgba(255,255,255,.22);
    --h-shadow: rgba(0,0,0,.45);
    --h-gold1: #d4af37;
    --h-gold2: #fff2b6;
  }

  body{
    background:
      radial-gradient(1100px 620px at 18% 16%, rgba(0,255,214,.22), transparent 60%),
      radial-gradient(980px 650px at 86% 18%, rgba(212,175,55,.18), transparent 62%),
      radial-gradient(1200px 760px at 50% 92%, rgba(0,164,255,.14), transparent 62%),
      linear-gradient(180deg, #0a7f86 0%, #07565c 40%, #052a2d 100%) !important;
    background-attachment: fixed !important;
    color: rgba(255,255,255,.92) !important;
  }

  /* Override earlier light theme grid so it doesn't look white */
  body:before{
    opacity: .35 !important;
    mask-image: radial-gradient(closest-side at 50% 35%, black 0%, transparent 78%) !important;
  }

  /* Replace generic purple gradient with HALLAYM teal */
  .gradient-bg{
    background: linear-gradient(135deg, var(--h-teal-1) 0%, var(--h-teal-2) 55%, #064a50 100%) !important;
  }

  /* Glass surfaces */
  .hallaym-surface{
    background: linear-gradient(180deg, rgba(255,255,255,.18), rgba(255,255,255,.10)) !important;
    border: 1px solid var(--h-brd) !important;
    box-shadow: 0 22px 70px var(--h-shadow) !important;
    backdrop-filter: blur(22px);
    -webkit-backdrop-filter: blur(22px);
    border-radius: 22px;
  }

  /* Headline like logo text */
  .hallaym-title{
    font-weight: 900;
    letter-spacing: .6px;
    background: linear-gradient(180deg, #cffff6, #00ffd5);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  /* Golden ring emblem */
  .hallaym-emblem{
    position: relative;
    width: 52px;
    height: 52px;
    border-radius: 16px;
    background: rgba(0,0,0,.26);
    display:flex;
    align-items:center;
    justify-content:center;
    box-shadow: 0 20px 60px rgba(0,0,0,.35);
  }
  .hallaym-emblem:before{
    content:"";
    position:absolute;
    inset:-2px;
    border-radius:18px;
    padding:2px;
    background: linear-gradient(135deg, var(--h-gold1), var(--h-gold2), var(--h-gold1));
    -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
    -webkit-mask-composite: xor;
            mask-composite: exclude;
  }
  .hallaym-emblem:after{
    content:"";
    position:absolute;
    left:-10px;
    top:10px;
    width:10px;
    height:10px;
    border-radius:999px;
    background: radial-gradient(circle, #fff, rgba(255,255,255,0));
    filter: blur(.2px);
    box-shadow: 0 0 18px rgba(255,255,255,.65);
    opacity:.85;
  }

  /* Upload overlay */
  #uploadOverlay{
    background: rgba(0,0,0,.45);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
  }
  #uploadOverlayCard{
    background: rgba(0,0,0,.38);
    border: 1px solid rgba(255,255,255,.18);
    box-shadow: 0 30px 110px rgba(0,0,0,.55);
    backdrop-filter: blur(26px);
    -webkit-backdrop-filter: blur(26px);
    border-radius: 24px;
  }
  #uploadRing{
    position: relative;
  }
  #uploadRing:before{
    content:"";
    position:absolute;
    inset:-2px;
    border-radius:26px;
    padding:2px;
    background: linear-gradient(135deg, var(--h-gold1), var(--h-gold2), var(--h-gold1));
    -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
    -webkit-mask-composite: xor;
            mask-composite: exclude;
  }
  #uploadBar{
    transition: width .15s linear;
  }
  @media(max-width:640px){
    #uploadOverlayCard{ padding: 18px !important; }
  }
</style>

  <link rel="stylesheet" href="/ui-glass-theme.css" />
</head>

<script>
  // Recording retry queue (IndexedDB). Large blobs cannot live in localStorage safely.
  const idbLessonQueue = (function(){
    const DB='schat_recordings';
    const STORE='queue';
    function openDB(){
      return new Promise((resolve,reject)=>{
        const req=indexedDB.open(DB,1);
        req.onupgradeneeded=()=>{ const db=req.result; if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE,{keyPath:'id'}); };
        req.onsuccess=()=>resolve(req.result);
        req.onerror=()=>reject(req.error);
      });
    }
    async function put(item){
      const db=await openDB();
      return new Promise((resolve,reject)=>{
        const tx=db.transaction(STORE,'readwrite');
        tx.objectStore(STORE).put(item);
        tx.oncomplete=()=>resolve(true);
        tx.onerror=()=>reject(tx.error);
      });
    }
    async function list(){
      const db=await openDB();
      return new Promise((resolve,reject)=>{
        const tx=db.transaction(STORE,'readonly');
        const req=tx.objectStore(STORE).getAll();
        req.onsuccess=()=>resolve(req.result||[]);
        req.onerror=()=>reject(req.error);
      });
    }
    async function del(id){
      const db=await openDB();
      return new Promise((resolve,reject)=>{
        const tx=db.transaction(STORE,'readwrite');
        tx.objectStore(STORE).delete(id);
        tx.oncomplete=()=>resolve(true);
        tx.onerror=()=>reject(tx.error);
      });
    }
    return {put,list,del};
  })();

  async function retryQueuedRecordings(){
    try{
      const items = await idbLessonQueue.list();
      if(!items.length) return;
      for(const it of items){
        try{
          const token = localStorage.getItem('token') || it.token || '';
          const fd = new FormData();
          fd.append('recording', it.blob, it.filename || `lesson_${it.lessonId}.webm`);
          if(it.title) fd.append('title', it.title);
          const res = await fetch(`/api/group-lessons/${it.lessonId}/recording`, { method:'POST', headers:{'Authorization':`Bearer ${token}`}, body: fd });
          if(res.ok){
            await idbLessonQueue.del(it.id);
            notify('Oldingi yozuv ham saqlandi ✅', 'ok');
          }
        }catch(e){ /* keep */ }
      }
    }catch(_){}
  }
  window.addEventListener('online', retryQueuedRecordings);
  document.addEventListener('visibilitychange', ()=>{ if(!document.hidden) retryQueuedRecordings(); });
</script>

<body class="bg-gray-50 min-h-screen">

<!-- Upload Progress Overlay (Teacher Recording) -->
<div id="uploadOverlay" class="fixed inset-0 hidden items-center justify-center z-[99998]">
  <div id="uploadRing" class="w-[92%] max-w-md">
    <div id="uploadOverlayCard" class="p-8 text-center">
      <div class="hallaym-title text-xl mb-4">Video yuklanmoqda...</div>
      <div class="w-full bg-white/10 rounded-full h-3 overflow-hidden">
        <div id="uploadBar" class="h-full bg-gradient-to-r from-cyan-300 to-emerald-300" style="width:0%"></div>
      </div>
      <div id="uploadPercent" class="mt-3 text-white/85 font-extrabold">0%</div>
      <div id="uploadHint" class="mt-1 text-white/55 text-xs">Internet sekin bo‘lsa ham, tugagach avtomatik saqlanadi.</div>
    </div>
  </div>
</div>

<div id="toastHost" style="position:fixed;top:16px;left:50%;transform:translateX(-50%);z-index:99999;display:flex;flex-direction:column;gap:10px;max-width:min(92vw,520px);"></div>

<!-- Mobile Drawer -->
<div id="mobileDrawerWrap" class="fixed inset-0 z-[70] hidden md:hidden" aria-hidden="true">
  <div class="absolute inset-0 bg-black/40 backdrop-blur-sm" onclick="closeMobileMenu()"></div>
  <aside id="mobileDrawer" class="absolute right-0 top-0 h-full w-[min(92vw,360px)] bg-white/10 border-l border-white/20 backdrop-blur-2xl p-4 overflow-y-auto">
    <div class="flex items-center justify-between">
      <div class="font-extrabold tracking-tight text-white">Menu</div>
      <button class="p-2 rounded-xl hover:bg-white/10" aria-label="Close" onclick="closeMobileMenu()"><i class="fas fa-xmark text-white"></i></button>
    </div>
    <div class="mt-4 grid gap-2">
      <a href="/groups.html" class="flex items-center gap-3 px-4 py-3 rounded-2xl bg-white/10 hover:bg-white/15 border border-white/15 text-white font-semibold"><i class="fas fa-arrow-left w-5 text-center"></i><span>Back to Groups</span></a>
<button id="mInfo" onclick="toggleInfoPanel(); closeMobileMenu();" class="flex items-center gap-3 px-4 py-3 rounded-2xl bg-white/10 hover:bg-white/15 border border-white/15 text-white font-semibold text-left"><i class="fas fa-circle-info w-5 text-center"></i><span>Group Info</span></button>
<button id="mInvite" onclick="document.getElementById('inviteSearch')?.scrollIntoView({behavior:'smooth',block:'start'}); closeMobileMenu();" class="flex items-center gap-3 px-4 py-3 rounded-2xl bg-white/10 hover:bg-white/15 border border-white/15 text-white font-semibold text-left"><i class="fas fa-user-plus w-5 text-center"></i><span>Invite</span></button>
<button id="mVideoCall" onclick="startGroupVideoCall(); closeMobileMenu();" class="flex items-center gap-3 px-4 py-3 rounded-2xl bg-white/10 hover:bg-white/15 border border-white/15 text-white font-semibold text-left">
  <i class="fas fa-video w-5 text-center"></i><span>Video Call</span>
</button>
<button id="mVoiceCall" onclick="startGroupAudioCall(); closeMobileMenu();" class="flex items-center gap-3 px-4 py-3 rounded-2xl bg-white/10 hover:bg-white/15 border border-white/15 text-white font-semibold text-left">
  <i class="fas fa-phone w-5 text-center"></i><span>Voice Call</span>
</button>
<button id="mLessons" onclick="goToGroupLessons(); closeMobileMenu();" class="flex items-center gap-3 px-4 py-3 rounded-2xl bg-white/10 hover:bg-white/15 border border-white/15 text-white font-semibold text-left">
  <i class="fas fa-book-open w-5 text-center"></i><span>O‘tilgan darslar</span>
</button>

<button id="mLogout2" onclick="logout(); closeMobileMenu();" class="flex items-center gap-3 px-4 py-3 rounded-2xl bg-white/10 hover:bg-white/15 border border-white/15 text-white font-semibold text-left"><i class="fas fa-right-from-bracket w-5 text-center"></i><span>Logout</span></button>
    </div>
  </aside>
</div>


<script>
  // Minimal toast (no popups)
  function notify(msg, type){
    try{
      const host=document.getElementById('toastHost');
      if(!host) return;
      const el=document.createElement('div');
      el.style.cssText="padding:12px 14px;border-radius:14px;border:1px solid rgba(255,255,255,.18);background:rgba(15,23,42,.72);backdrop-filter:blur(14px);-webkit-backdrop-filter:blur(14px);box-shadow:0 18px 55px rgba(0,0,0,.35);color:#fff;font-weight:700;font-size:13px;display:flex;gap:10px;align-items:flex-start;";
      const icon = type==='ok'?'✅':(type==='warn'?'⚠️':(type==='err'?'❌':'ℹ️'));
      el.innerHTML = `<span style="margin-top:1px">${icon}</span><div style="font-weight:650;line-height:1.3">${String(msg||'')}</div>`;
      host.appendChild(el);
      setTimeout(()=>{ el.style.opacity='0'; el.style.transform='translateY(-6px)'; el.style.transition='all .25s ease'; }, 4200);
      setTimeout(()=>{ try{ el.remove(); }catch(_){} }, 4700);
    }catch(_){}
  }
  // Redirect most alert() to toast
  window.alert = function(msg){ notify(msg,'info'); };
</script>
<script>
  function toggleMobileMenu(){
    const w=document.getElementById('mobileDrawerWrap');
    if(!w) return;
    if(w.classList.contains('hidden')){
      w.classList.remove('hidden');
      document.body.style.overflow='hidden';
    } else {
      w.classList.add('hidden');
      document.body.style.overflow='';
    }
  }
  function closeMobileMenu(){
    const w=document.getElementById('mobileDrawerWrap');
    if(!w) return;
    w.classList.add('hidden');
    document.body.style.overflow='';
  }
  document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeMobileMenu(); });
</script>

<div id="drawerOverlay" aria-hidden="true"></div>

    <!-- Navigation -->
    <nav class="gradient-bg text-white h-16">
        <div class="container mx-auto px-4 h-full flex items-center justify-between">
            <a href="/groups.html" class="flex items-center space-x-2">
                <i class="fas fa-arrow-left"></i>
                <span class="font-semibold">Back to Groups</span>
            </a>
            <div class="flex items-center space-x-4">
                <button id="menuBtn" class="p-2 hover:bg-white/10 rounded-full md:hidden" aria-label="Menu" onclick="toggleMobileMenu()"><i class="fas fa-bars"></i></button>
                <button onclick="toggleInfoPanel()" class="p-2 hover:bg-white/10 rounded-full">
                    <i class="fas fa-info-circle"></i>
                </button>
                <a href="#" onclick="logout()" class="p-2 hover:bg-white/10 rounded-full">
                    <i class="fas fa-sign-out-alt"></i>
                </a>
            </div>
        </div>
    </nav>

    <!-- Main Layout -->
    <div class="container mx-auto flex h-[calc(100vh-4rem)]">
        <!-- Chat Area -->
        <div class="flex-1 flex flex-col hallaym-surface">
            <!-- Group Header -->
            <div class="border-b border-white/15 p-4">
                <div class="flex items-center justify-between">
                    <div class="flex items-center space-x-3">
                        <div class="hallaym-emblem">
                            <i class="fas fa-users text-white text-xl"></i>
                        </div>
                        <div>
                            <h1 id="groupName" class="text-xl hallaym-title">Loading...</h1>
                            <p id="groupMembers" class="text-sm text-gray-600">0 members</p>
                        </div>
                    </div>
                    <div id="groupActions" class="flex items-center space-x-2">
                        <!-- Actions will be loaded here -->
                    </div>
                </div>
                <p id="groupDescription" class="text-gray-600 mt-2"></p>
            </div>
            
            <!-- Messages Container -->
            <div class="flex-1 overflow-y-auto p-4 space-y-4" id="messagesContainer">
                <!-- Messages will be loaded here -->
                <div class="text-center mt-20">
                    <i class="fas fa-comments text-4xl text-gray-300 mb-4"></i>
                    <h3 class="text-xl font-semibold text-gray-500">Group Chat</h3>
                    <p class="text-gray-400">Start the conversation!</p>
                </div>
            </div>
            
            <!-- Message Input -->
            <div class="border-t border-white/15 p-4 hallaym-surface">
                <div class="flex space-x-2">
                    <button onclick="attachMedia()" class="p-3 hover:bg-gray-100 rounded-full">
                        <i class="fas fa-paperclip text-gray-600"></i>
                    </button>
                    <input type="text" id="messageInput" 
                           class="flex-1 border border-gray-300 rounded-full px-4 py-3 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent"
                           placeholder="Type a message to the group..." 
                           onkeyup="handleEnter(event)">
                    <button onclick="sendGroupMessage()" 
                            class="gradient-bg text-white px-6 py-3 rounded-full font-semibold hover:opacity-90 transition">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Info Panel -->
        <div id="infoPanel" class="w-80 border-l border-white/15 hallaym-surface overflow-y-auto hidden md:block">
            <div class="p-6">
                <!-- Group Info -->
                <div class="mb-8">
                    <h3 class="font-bold text-gray-800 text-lg mb-4">Group Information</h3>
                    <div class="space-y-4">
                        <div>
                            <label class="text-sm text-gray-500">Created By</label>
                            <div class="flex items-center space-x-2 mt-1">
                                <img id="creatorAvatar" src="" class="w-8 h-8 rounded-full">
                                <span id="creatorName" class="font-medium"></span>
                            </div>
                        </div>
                        <div>
                            <label class="text-sm text-gray-500">Created Date</label>
                            <p id="createdDate" class="font-medium"></p>
                        </div>
                        <div>
                            <label class="text-sm text-gray-500">University</label>
                            <p id="groupUniversity" class="font-medium"></p>
                        </div>
                        <div>
                            <label class="text-sm text-gray-500">Description</label>
                            <p id="fullDescription" class="text-gray-700"></p>
                        </div>
                    </div>
                </div>
                
                <!-- Members List -->
                <div>
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="font-bold text-gray-800 text-lg">Members</h3>
                        <span id="membersCount" class="text-sm text-gray-500">0 members</span>
                    </div>
                    <div id="membersList" class="space-y-3">
                        <!-- Members will be loaded here -->
                    </div>
                </div>
                
                <!-- Invite Section -->
                <div class="mt-8 pt-6 border-t border-gray-200">
                    <h3 class="font-bold text-gray-800 text-lg mb-4">Invite Members</h3>
                    <div class="relative mb-3">
                        <input type="text" id="inviteSearch" 
                               class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent"
                               placeholder="Search users...">
                    </div>
                    <div id="inviteResults" class="space-y-2 max-h-40 overflow-y-auto mb-3">
                        <!-- Invite results will appear here -->
                    </div>
                    <button onclick="copyInviteLink()" 
                            class="w-full bg-gray-100 text-gray-700 py-2 rounded-lg font-medium hover:bg-gray-200 transition">
                        <i class="fas fa-link mr-2"></i> Copy Invite Link
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Media Modal -->
    <div id="mediaModal" class="fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center">
        <div class="bg-white rounded-lg max-w-2xl max-h-[90vh] overflow-hidden">
            <div class="p-4 border-b border-gray-200 flex justify-between items-center">
                <h3 class="font-bold text-gray-800">Media Preview</h3>
                <button onclick="closeMediaModal()" class="p-2 hover:bg-gray-100 rounded-full">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="p-4">
                <img id="mediaPreview" src="" class="max-w-full max-h-[70vh] mx-auto">
            </div>
        </div>
    </div>

    <script>
        let socket = null;
        let currentUser = null;
        let currentGroup = null;
        let groupId = null;
        const __urlParams = new URLSearchParams(window.location.search);
        const OBSERVER_MODE = (__urlParams.get('observer') === '1' || __urlParams.get('asObserver') === '1');
        const AUTO_JOIN_CALL = (__urlParams.get('autoJoin') === '1');

        
        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            await checkAuth();
            await getGroupIdFromURL();
            await loadCurrentUser();
            await loadGroupInfo();
            setupSocket();
            loadGroupMessages();
        });
        
        // Get group ID from URL
        function getGroupIdFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            groupId = urlParams.get('id');
            
            if (!groupId) {
                alert('Group ID not found in URL');
                window.location.href = '/groups.html';
            }
        }
        
        // Authentication
        async function checkAuth() {
            const token = localStorage.getItem('token');
            if (!token) {
                window.location.href = '/login.html';
                return;
            }
            
            try {
                const response = await fetch('/api/me', {
                    headers: { 
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    if (response.status === 401 || response.status === 403) {
                        localStorage.removeItem('token');
                        window.location.href = '/login.html';
                        return;
                    }
                    console.warn('Auth check returned non-ok status:', response.status);
                } else {
                    const data = await response.json();
                    if (!data.success) {
                        localStorage.removeItem('token');
                        window.location.href = '/login.html';
                        return;
                    }
                }
            } catch (error) {
                console.error('Auth check error:', error);
                if (error.name === 'TypeError' || error.message.includes('Failed to fetch')) {
                    console.error('Network error during auth check');
                } else {
                    localStorage.removeItem('token');
                    window.location.href = '/login.html';
                }
            }
        }
        
        // Load current user
        async function loadCurrentUser() {
            try {
                const response = await fetch('/api/me', {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
                });
                const data = await response.json();
                if (data.success) {
                    currentUser = data.user;
                }
                // If group already loaded, rebuild actions (important on mobile)
                try { if (currentGroup) setupGroupActions(currentGroup); } catch(e){}

            } catch (error) {
                console.error('Failed to load user:', error);
            }
        }
        
        // Load group information
        async function loadGroupInfo() {
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`/api/groups/${groupId}`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    currentGroup = data.group;
                    renderGroupInfo(data.group);
                    renderMembers(data.group.members);
                    // Ensure currentUser is loaded before building action menu (mobile needs it)
                    if (!currentUser) { try { await loadCurrentUser(); } catch(e){} }
                    setupGroupActions(data.group);
                } else {
                    alert('Group not found or access denied');
                    window.location.href = '/groups.html';
                }
            } catch (error) {
                console.error('Failed to load group info:', error);
            }
        }
        
        // Render group information
        function renderGroupInfo(group) {
            document.getElementById('groupName').textContent = group.name;
            document.getElementById('groupMembers').textContent = `${group.members?.length || 0} members`;
            document.getElementById('groupDescription').textContent = group.description || 'No description';
            document.getElementById('fullDescription').textContent = group.description || 'No description provided';
            document.getElementById('groupUniversity').textContent = group.university || 'All Universities';
            
            // Creator info
            if (group.creatorId) {
                document.getElementById('creatorAvatar').src = group.creatorId.avatar;
                document.getElementById('creatorName').textContent = group.creatorId.nickname;
            }
            
            // Created date
            const createdDate = new Date(group.createdAt);
            document.getElementById('createdDate').textContent = createdDate.toLocaleDateString();
            
            // Members count
            document.getElementById('membersCount').textContent = `${group.members?.length || 0} members`;
        }
        
        // Render members list
        function renderMembers(members) {
            const container = document.getElementById('membersList');
            
            if (!members || members.length === 0) {
                container.innerHTML = '<p class="text-gray-500 text-center py-4">No members</p>';
                return;
            }
            
            container.innerHTML = members.map(member => `
                <div class="flex items-center justify-between p-2 hover:bg-gray-50 rounded-lg">
                    <div class="flex items-center space-x-3">
                        <img src="${member.avatar||""}" class="w-10 h-10 rounded-full member-avatar" onerror="this.onerror=null;this.src='data:image/svg+xml;utf8,&lt;svg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; width=&#x27;80&#x27; height=&#x27;80&#x27;&gt;&lt;rect width=&#x27;100%&#x27; height=&#x27;100%&#x27; fill=&#x27;#ddd&#x27;/&gt;&lt;circle cx=&#x27;40&#x27; cy=&#x27;30&#x27; r=&#x27;16&#x27; fill=&#x27;#bbb&#x27;/&gt;&lt;rect x=&#x27;18&#x27; y=&#x27;52&#x27; width=&#x27;44&#x27; height=&#x27;20&#x27; rx=&#x27;10&#x27; fill=&#x27;#bbb&#x27;/&gt;&lt;/svg&gt;';">
                        <div>
                            <h4 class="font-medium text-gray-800">${member.nickname}</h4>
                            <p class="text-sm text-gray-500">@${member.username}</p>
                        </div>
                    </div>
                    <div class="flex items-center space-x-1">
                        ${member._id === currentGroup.creatorId?._id ? 
                            '<span class="text-xs bg-purple-100 text-purple-600 px-2 py-1 rounded">Admin</span>' : ''}
                        ${member.isOnline ? 
                            '<div class="w-2 h-2 bg-green-500 rounded-full" title="Online"></div>' : 
                            '<div class="w-2 h-2 bg-gray-400 rounded-full" title="Offline"></div>'}
                    </div>
                </div>
            `).join('');
        }
        
        // Setup group actions based on user role
        function setupGroupActions(group) {
            const container = document.getElementById('groupActions');
            const isCreator = currentUser._id === group.creatorId?._id;
            const isMember = group.members?.some(m => m._id === currentUser._id);

            if (!container) return;

            // helpers
            const mobileWrapOpen = `
              <div class="sm:hidden relative">
                <button id="groupActionsToggle" onclick="toggleGroupActionsMenu()" class="px-3 py-2 rounded-xl bg-white/10 border border-white/15 hover:bg-white/15 text-gray-800 dark:text-white">
                  <i class="fas fa-ellipsis-vertical"></i>
                </button>
                <div id="groupActionsMenu" class="hidden absolute right-0 mt-2 w-64 rounded-2xl bg-white/80 dark:bg-black/70 border border-white/20 backdrop-blur-2xl overflow-hidden shadow-2xl z-40">
            `;
            const mobileWrapClose = `
                </div>
              </div>
            `;
            const mobileItem = (icon, label, onClick, danger=false) => `
              <button onclick="${onClick}; closeGroupActionsMenu()" class="w-full text-left px-4 py-3 hover:bg-black/5 dark:hover:bg-white/10 flex items-center gap-3 ${danger?'text-red-600 dark:text-red-300':''}">
                <i class="${icon} w-5 text-center"></i><span class="font-semibold">${label}</span>
              </button>
            `;
            const divider = `<div class="h-px bg-black/10 dark:bg-white/10"></div>`;

            if (!isMember) {
                container.innerHTML = `
                  <div class="hidden sm:flex items-center space-x-2">
                    <button onclick="joinGroup()" class="gradient-bg text-white px-4 py-2 rounded-lg font-medium hover:opacity-90 transition">
                      <i class="fas fa-user-plus mr-2"></i> Join Group
                    </button>
                  </div>
                  ${mobileWrapOpen}
                    ${mobileItem('fas fa-user-plus','Join Group','joinGroup()')}
                  ${mobileWrapClose}
                `;
                return;
            }

            if (isCreator) {
                container.innerHTML = `
                  <div class="hidden sm:flex items-center space-x-2">
                    <button onclick="startGroupVideoCall()" class="px-4 py-2 bg-indigo-600 text-white rounded-lg font-medium hover:bg-indigo-700 transition">
                      <i class="fas fa-video mr-2"></i> Video Call
                    </button>
                    <button onclick="startGroupAudioCall()" class="px-4 py-2 bg-green-600 text-white rounded-lg font-medium hover:bg-green-700 transition">
                      <i class="fas fa-phone mr-2"></i> Voice Call
                    </button>
                    <button onclick="goToGroupLessons()" class="px-4 py-2 bg-purple-600 text-white rounded-lg font-medium hover:bg-purple-700 transition">
                      <i class="fas fa-book-open mr-2"></i> O'tilgan darslar
                    </button>
                    <button onclick="editGroup()" class="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition">
                      <i class="fas fa-edit mr-2"></i> Edit
                    </button>
                    <button onclick="deleteGroup()" class="px-4 py-2 bg-red-100 text-red-600 rounded-lg hover:bg-red-200 transition">
                      <i class="fas fa-trash mr-2"></i> Delete
                    </button>
                  </div>
                  ${mobileWrapOpen}
                    ${mobileItem('fas fa-video','Video Call','startGroupVideoCall()')}
                    ${mobileItem('fas fa-phone','Voice Call','startGroupAudioCall()')}
                    ${mobileItem('fas fa-book-open','O\'tilgan darslar','goToGroupLessons()')}
                    ${divider}
                    ${mobileItem('fas fa-edit','Edit','editGroup()')}
                    ${mobileItem('fas fa-trash','Delete','deleteGroup()', true)}
                  ${mobileWrapClose}
                `;
            } else {
                container.innerHTML = `
                  <div class="hidden sm:flex items-center space-x-2">
                    <button onclick="startGroupVideoCall()" class="px-4 py-2 bg-indigo-600 text-white rounded-lg font-medium hover:bg-indigo-700 transition">
                      <i class="fas fa-video mr-2"></i> Video Call
                    </button>
                    <button onclick="startGroupAudioCall()" class="px-4 py-2 bg-green-600 text-white rounded-lg font-medium hover:bg-green-700 transition">
                      <i class="fas fa-phone mr-2"></i> Voice Call
                    </button>
                    <button onclick="goToGroupLessons()" class="px-4 py-2 bg-purple-600 text-white rounded-lg font-medium hover:bg-purple-700 transition">
                      <i class="fas fa-book-open mr-2"></i> O'tilgan darslar
                    </button>
                    <button onclick="leaveGroup()" class="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition">
                      <i class="fas fa-sign-out-alt mr-2"></i> Leave
                    </button>
                  </div>
                  ${mobileWrapOpen}
                    ${mobileItem('fas fa-video','Video Call','startGroupVideoCall()')}
                    ${mobileItem('fas fa-phone','Voice Call','startGroupAudioCall()')}
                    ${mobileItem('fas fa-book-open','O\'tilgan darslar','goToGroupLessons()')}
                    ${divider}
                    ${mobileItem('fas fa-right-from-bracket','Leave','leaveGroup()', true)}
                  ${mobileWrapClose}
                `;
            }
        }

        function toggleGroupActionsMenu(){
          const m=document.getElementById('groupActionsMenu');
          if(!m) return;
          m.classList.toggle('hidden');
        }
        function closeGroupActionsMenu(){
          const m=document.getElementById('groupActionsMenu');
          if(m) m.classList.add('hidden');
        }
        document.addEventListener('click',(e)=>{
          const btn=document.getElementById('groupActionsToggle');
          const menu=document.getElementById('groupActionsMenu');
          if(!menu || menu.classList.contains('hidden')) return;
          if(btn && (btn===e.target || btn.contains(e.target))) return;
          if(menu===e.target || menu.contains(e.target)) return;
          closeGroupActionsMenu();
        });

        // Navigate to group lessons / recordings page / recordings page
        function goToGroupLessons() {
            const gid = groupId || new URLSearchParams(location.search).get('id');
            if (!gid) return alert('Group ID topilmadi');
            // Support both variants used across pages
            const ret = encodeURIComponent(window.location.pathname + window.location.search);
            window.location.href = `/group-lessons.html?groupId=${encodeURIComponent(gid)}&return=${ret}`;
        }
        
        
        async function updateLessonMeta(lessonId, meta){
            try{
                if(!lessonId) return;
                const token = localStorage.getItem('token') || '';
                const res = await fetch(`/api/group-lessons/${encodeURIComponent(lessonId)}/meta`, {
                    method:'PUT',
                    headers:{'Content-Type':'application/json','Authorization':`Bearer ${token}`},
                    body: JSON.stringify(meta||{})
                });
                return res.ok;
            }catch(e){ console.warn('updateLessonMeta failed', e); }
        }

// Setup Socket.IO
        function setupSocket() {
            const token = localStorage.getItem('token');
            socket = io();
            
            socket.emit('authenticate', token);
            socket.emit('joinGroup', groupId);
            
            // Listen for new group messages
            socket.on('newGroupMessage', (message) => {
                if (message.groupId === groupId) {
                    addGroupMessageToUI(message);
                }
            });
            
            // Listen for member updates
            setupGroupCallSocketHandlers();

            socket.on('groupMemberUpdate', (data) => {
                if (data.groupId === groupId) {
                    updateGroupMembers(data);
                }
            });
        }
        
        // Load group messages
        async function loadGroupMessages() {
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`/api/groups/${groupId}/messages`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    renderGroupMessages(data.messages);
                }
            } catch (error) {
                console.error('Failed to load messages:', error);
            }
        }
        
        
        function openUserProfile(userId){
            if (!userId) return;
            // profile.html already exists in the project (and respects token)
            window.location.href = `/profile.html?id=${encodeURIComponent(userId)}`;
        }
    
// Render group messages
        function renderGroupMessages(messages) {
            const container = document.getElementById('messagesContainer');
            
            if (!messages || messages.length === 0) {
                return;
            }
            
            container.innerHTML = messages.map(msg => `
                <div class="message">
                    <div class="flex items-start space-x-2">
                        <img src="${msg.senderId?.avatar}" class="w-8 h-8 rounded-full cursor-pointer" onclick="openUserProfile('${msg.senderId?._id}')" title="Profil">
                        <div class="flex-1">
                            <div class="flex items-center space-x-2 mb-1">
                                <span class="font-medium text-gray-800 cursor-pointer hover:underline" onclick="openUserProfile('${msg.senderId?._id}')" title="Profil">${msg.senderId?.nickname}</span>
                                <span class="text-xs text-gray-500">${formatTime(msg.createdAt)}</span>
                            </div>
                            <div class="message-bubble ${msg.senderId?._id === currentUser._id ? 'sent' : 'received'} p-3">
                                ${msg.mediaUrl ? `
                                    <div class="mb-2">
                                        ${msg.mediaType === 'image' ? 
                                            `<img src="${msg.mediaUrl}" class="max-w-full rounded-lg cursor-pointer" 
                                                 style="max-height: 300px;" onclick="viewMedia('${msg.mediaUrl}')">` :
                                            `<video src="${msg.mediaUrl}" controls class="max-w-full rounded-lg" style="max-height: 300px;"></video>`
                                        }
                                    </div>
                                ` : ''}
                                <p>${msg.text}</p>
                            </div>
                        </div>
                    </div>
                </div>
            `).join('');
            
            // Scroll to bottom
            container.scrollTop = container.scrollHeight;
        }
        
        // Send group message
        async function sendGroupMessage() {
            const input = document.getElementById('messageInput');
            const text = input.value.trim();
            
            if (!text || !currentGroup) return;
            
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`/api/groups/${groupId}/messages`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        // FIX: backend expects "Bearer <token>" (see authenticateToken split)
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        text: text
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    input.value = '';
                    addGroupMessageToUI(data.message);
                    
                    // Emit via socket
                    if (socket) {
                        socket.emit('groupMessage', {
                            groupId: groupId,
                            text: text
                        });
                    }
                }
            } catch (error) {
                console.error('Failed to send message:', error);
            }
        }
        
        // Add group message to UI
        function addGroupMessageToUI(message) {
            const container = document.getElementById('messagesContainer');
            
            // If empty container
            if (container.innerHTML.includes('Start the conversation')) {
                container.innerHTML = '';
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            messageDiv.innerHTML = `
                <div class="flex items-start space-x-2">
                    <img src="${message.senderId?.avatar}" class="w-8 h-8 rounded-full cursor-pointer" onclick="openUserProfile('${message.senderId?._id}')" title="Profil">
                    <div class="flex-1">
                        <div class="flex items-center space-x-2 mb-1">
                            <span class="font-medium text-gray-800 cursor-pointer hover:underline" onclick="openUserProfile('${message.senderId?._id}')" title="Profil">${message.senderId?.nickname}</span>
                            <span class="text-xs text-gray-500">${formatTime(message.createdAt)}</span>
                        </div>
                        <div class="message-bubble ${message.senderId?._id === currentUser._id ? 'sent' : 'received'} p-3">
                            ${message.mediaUrl ? `
                                <div class="mb-2">
                                    ${message.mediaType === 'image' ? 
                                        `<img src="${message.mediaUrl}" class="max-w-full rounded-lg cursor-pointer" 
                                             style="max-height: 300px;" onclick="viewMedia('${message.mediaUrl}')">` :
                                        `<video src="${message.mediaUrl}" controls class="max-w-full rounded-lg" style="max-height: 300px;"></video>`
                                    }
                                </div>
                            ` : ''}
                            <p>${message.text}</p>
                        </div>
                    </div>
                </div>
            `;
            
            container.appendChild(messageDiv);
            container.scrollTop = container.scrollHeight;
        }
        
        // Join group
        async function joinGroup() {
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`/api/groups/${groupId}/join`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                const data = await response.json();
                if (data.success) {
                    alert('Successfully joined the group!');
                    loadGroupInfo(); // Reload group info
                } else {
                    alert(data.error || 'Failed to join group');
                }
            } catch (error) {
                console.error('Join group error:', error);
                alert('Failed to join group');
            }
        }
        
        // Leave group
        async function leaveGroup() {
            if (!confirm('Are you sure you want to leave this group?')) {
                return;
            }
            
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`/api/groups/${groupId}/leave`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                const data = await response.json();
                if (data.success) {
                    alert('You have left the group');
                    window.location.href = '/groups.html';
                } else {
                    alert(data.error || 'Failed to leave group');
                }
            } catch (error) {
                console.error('Leave group error:', error);
                alert('Failed to leave group');
            }
        }
        
        // Edit group
        function editGroup() {
            alert('Edit group functionality would open a modal');
        }
        
        // Delete group
        async function deleteGroup() {
            if (!confirm('Are you sure you want to delete this group? This action cannot be undone.')) {
                return;
            }
            
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`/api/groups/${groupId}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                const data = await response.json();
                if (data.success) {
                    alert('Group deleted successfully');
                    window.location.href = '/groups.html';
                } else {
                    alert(data.error || 'Failed to delete group');
                }
            } catch (error) {
                console.error('Delete group error:', error);
                alert('Failed to delete group');
            }
        }
        
        // Toggle info panel
        function toggleInfoPanel(){
  const panel=document.getElementById("infoPanel");
  const ov=document.getElementById("drawerOverlay");
  if(!panel) return;
  const isMobile = window.matchMedia("(max-width: 640px)").matches;
  if(isMobile){
    const open = panel.classList.toggle("open");
    if(ov) ov.classList.toggle("show", open);
    document.body.style.overflow = open ? "hidden" : "";
  } else {
    panel.classList.toggle("hidden");
  }
}
// Handle enter key
        function handleEnter(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendGroupMessage();
            }
        }
        
        // Attach media
        function attachMedia() {
            alert('Media upload would be implemented');
        }
        
        // View media in modal
        function viewMedia(url) {
            document.getElementById('mediaPreview').src = url;
            document.getElementById('mediaModal').classList.remove('hidden');
        }
        
        function closeMediaModal() {
            document.getElementById('mediaModal').classList.add('hidden');
        }
        
        // Copy invite link
        function copyInviteLink() {
            const inviteLink = `${window.location.origin}/group.html?id=${groupId}`;
            navigator.clipboard.writeText(inviteLink).then(() => {
                alert('Invite link copied to clipboard!');
            });
        }
        
        // Search users for invitation
        async function searchInviteUsers(query) {
            if (query.length < 2) return;
            
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`/api/search/users?query=${encodeURIComponent(query)}`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                const data = await response.json();
                const resultsContainer = document.getElementById('inviteResults');
                
                if (data.success && data.users.length > 0) {
                    // Filter out users already in group
                    const existingMembers = currentGroup.members.map(m => m._id);
                    const filteredUsers = data.users.filter(user => 
                        !existingMembers.includes(user._id) && user._id !== currentUser._id
                    );
                    
                    if (filteredUsers.length > 0) {
                        resultsContainer.innerHTML = filteredUsers.map(user => `
                            <div class="flex items-center justify-between p-2 hover:bg-gray-50 rounded-lg">
                                <div class="flex items-center space-x-2">
                                    <img src="${user.avatar}" class="w-8 h-8 rounded-full">
                                    <div>
                                        <h4 class="font-medium text-sm">${user.nickname}</h4>
                                        <p class="text-xs text-gray-500">@${user.username}</p>
                                    </div>
                                </div>
                                <button onclick="inviteUser('${user._id}')" 
                                        class="text-xs bg-purple-100 text-purple-600 px-2 py-1 rounded hover:bg-purple-200">
                                    Invite
                                </button>
                            </div>
                        `).join('');
                    } else {
                        resultsContainer.innerHTML = '<p class="text-gray-500 text-center py-2">All searched users are already in group</p>';
                    }
                } else {
                    resultsContainer.innerHTML = '<p class="text-gray-500 text-center py-2">No users found</p>';
                }
            } catch (error) {
                console.error('Search error:', error);
            }
        }
        
        // Invite user to group
        async function inviteUser(userId) {
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`/api/groups/${groupId}/invite`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        // FIX: backend expects "Bearer <token>"
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({ userId })
                });
                
                const data = await response.json();
                if (data.success) {
                    alert('User invited successfully!');
                    // Clear search
                    document.getElementById('inviteSearch').value = '';
                    document.getElementById('inviteResults').innerHTML = '';
                } else {
                    alert(data.error || 'Failed to invite user');
                }
            } catch (error) {
                console.error('Invite error:', error);
                alert('Failed to invite user');
            }
        }
        
        // Update group members
        function updateGroupMembers(data) {
            if (data.action === 'add') {
                // Add new member
                currentGroup.members.push(data.user);
            } else if (data.action === 'remove') {
                // Remove member
                currentGroup.members = currentGroup.members.filter(m => m._id !== data.userId);
            }
            
            renderMembers(currentGroup.members);
            document.getElementById('groupMembers').textContent = `${currentGroup.members.length} members`;
            document.getElementById('membersCount').textContent = `${currentGroup.members.length} members`;
            setupGroupActions(currentGroup);
        }
        
        // Format time
        function formatTime(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diff = now - date;
            
            if (diff < 60000) return 'just now';
            if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
            if (diff < 86400000) return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            return date.toLocaleDateString();
        }
        
        // Setup invite search
        document.getElementById('inviteSearch').addEventListener('input', (e) => {
            searchInviteUsers(e.target.value);
        });
        
        // Logout
        async function logout() {
            try {
                await fetch('/api/logout', {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
                });
            } catch (error) {
                // Ignore errors
            }
            
            localStorage.removeItem('token');
            window.location.href = '/login.html';
        }
    </script>

<div id="themeFab" title="Kunduzgi / Tungi">
  <i id="themeFabIcon" class="fa-solid fa-moon"></i>
  <span id="themeFabLabel">Tungi</span>
</div>
<script>
  (function(){
    const key='theme';
    const btn=document.getElementById('themeFab');
    const icon=document.getElementById('themeFabIcon');
    const label=document.getElementById('themeFabLabel');
    function apply(mode){
      if(mode==='dark') document.documentElement.classList.add('dark'); else document.documentElement.classList.remove('dark');
      localStorage.setItem(key, mode);
      icon.className = mode==='dark' ? 'fa-solid fa-sun' : 'fa-solid fa-moon';
      label.textContent = mode==='dark' ? 'Kunduzgi' : 'Tungi';
    }
    const saved=localStorage.getItem(key);
    const prefers=window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    apply(saved || (prefers?'dark':'light'));
    btn.addEventListener('click', ()=> apply(document.documentElement.classList.contains('dark') ? 'light' : 'dark'));
  })();

        
        // Shared audio constraints (used for mic capture and screen+cam mode)
        const AUDIO_CONSTRAINTS = { echoCancellation: true, noiseSuppression: true, autoGainControl: true, channelCount: 1 };
        // Back-compat alias (some older code referenced audioConstraints)
        const audioConstraints = AUDIO_CONSTRAINTS;
// ==================== GROUP CALL 
        // ==================== GROUP CALL (LIVEKIT SFU) ====================
        // Toggle:
        //   localStorage.setItem('call_transport','livekit')  // default SFU
        //   localStorage.setItem('call_transport','mesh')     // fallback P2P
        // Notes:
        // - TURN remains enabled for any P2P fallbacks and for WebRTC connectivity in general.
        // - For 100-500 users: use 'livekit' + audience mode (only a few publishers). Rendering 500 video tiles is not realistic.
        async function livekitFetchToken(roomName, { canPublish=false, canSubscribe=true, isSpeaker=false } = {}) {
            const token = localStorage.getItem('token');
            const res = await fetch('/api/livekit/token', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({ room: roomName, canPublish, canSubscribe, isSpeaker })
            });
            if (!res.ok) {
                const t = await res.text().catch(()=> '');
                throw new Error('LiveKit token error: ' + res.status + ' ' + t);
            }
            return await res.json();
        }

        function isTeacher() {
            return String(currentUser?.role || '').toLowerCase() === 'teacher';
        }

        function shouldUseLiveKit() {
            const v = (groupCall.transport || '').toLowerCase();
            if (v === 'livekit') return true;
            if (v === 'mesh') return false;
            // auto: if unknown, prefer livekit
            return true;
        }

        async function livekitDisconnect() {
            try {
                if (groupCall.lk?.room) {
                    await groupCall.lk.room.disconnect();
                }
            } catch (_) {}
            groupCall.lk = { room: null, connected: false };
        }

        async function livekitConnect(roomName, { publishMedia=false } = {}) {
            if (!window.livekit || !window.livekit.Room) throw new Error('LiveKit client not loaded');
            await livekitDisconnect();

            const isSpeaker = !!publishMedia;
            const tk = await livekitFetchToken(roomName, {
                canPublish: isSpeaker,
                canSubscribe: true,
                isSpeaker
            });

            const room = new livekit.Room({
                adaptiveStream: true,
                dynacast: true,
                stopLocalTrackOnUnpublish: true
            });

            // Render remote tracks
            room.on(livekit.RoomEvent.TrackSubscribed, (track, publication, participant) => {
                try {
                    const pid = String(participant.identity || participant.sid || '');
                    attachLiveKitTrack(pid, track, participant);
                } catch (e) { console.warn('TrackSubscribed attach failed', e); }
            });
            room.on(livekit.RoomEvent.TrackUnsubscribed, (track, publication, participant) => {
                try {
                    const pid = String(participant.identity || participant.sid || '');
                    detachLiveKitTrack(pid, track);
                } catch (_) {}
            });
            room.on(livekit.RoomEvent.ParticipantDisconnected, (participant) => {
                try { removeVideoTile(String(participant.identity || participant.sid || '')); } catch(_) {}
            });

            // Connect
            await room.connect(tk.url, tk.token);

            groupCall.lk = { room, connected: true };
            setGroupCallStatus('SFU ulandi (LiveKit) ✅');

            // Publish local only if speaker
            if (publishMedia) {
                // Strong audio DSP to reduce "shovqin" when devices close
                const constraints = {
                    audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true },
                    video: (groupCall.callType === 'audio') ? false : { width: { ideal: 1280 }, height: { ideal: 720 }, frameRate: { ideal: 30, max: 30 } }
                };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                groupCall.localStream = stream;

                // Publish tracks
                const tracks = [];
                stream.getAudioTracks().forEach(t => tracks.push(new livekit.LocalAudioTrack(t)));
                stream.getVideoTracks().forEach(t => tracks.push(new livekit.LocalVideoTrack(t)));
                for (const t of tracks) await room.localParticipant.publishTrack(t);

                // local preview
                try {
                    const meId = String(currentUser?._id || 'me');
                    addVideoTile(meId, stream, true);
                    const el = document.getElementById(`vid_${meId}`);
                    if (el) { el.srcObject = stream; el.muted = true; await el.play().catch(()=>{}); }
                } catch (_) {}
            } else {
                // Audience: force muted and no camera
                setGroupCallStatus('Audience mode: kamera/mikrofon o‘chiq');
            }

            updateCallControlUI();
            renderGroupCallLayout();
        }

        function attachLiveKitTrack(userId, track, participant) {
            if (!track) return;
            const uid = String(userId || '');
            addVideoTile(uid, null, false);

            const el = document.getElementById(`vid_${uid}`);
            if (!el) return;

            if (track.kind === 'video') {
                const ms = new MediaStream([track.mediaStreamTrack]);
                el.srcObject = ms;
                el.play().catch(()=>{});
            } else if (track.kind === 'audio') {
                // create/attach hidden audio element to avoid feedback loops; do NOT autoplay if same device
                let a = document.getElementById(`aud_${uid}`);
                if (!a) {
                    a = document.createElement('audio');
                    a.id = `aud_${uid}`;
                    a.autoplay = true;
                    a.playsInline = true;
                    a.style.display = 'none';
                    document.body.appendChild(a);
                }
                a.srcObject = new MediaStream([track.mediaStreamTrack]);
                a.play().catch(()=>{});
            }
        }

        function detachLiveKitTrack(userId, track) {
            const uid = String(userId || '');
            if (track?.kind === 'audio') {
                const a = document.getElementById(`aud_${uid}`);
                if (a) { try{ a.srcObject = null; }catch(_){} }
            }
            // video detach handled by tile remove when participant disconnected
        }


(WebRTC Mesh) ====================
        let groupCall = {
            active: false,
            groupId: null,
            callId: null,
            callType: 'video',
            transport: (localStorage.getItem('call_transport') || 'mesh'), // 'mesh' | 'livekit'
            lk: { room: null, connected: false },
            localStream: null,
            peers: new Map(), // remoteUserId -> RTCPeerConnection
            remoteStreams: new Map(), // remoteUserId -> MediaStream
            muted: false,
            cameraOff: false,
            starterId: null,
            incoming: null,
            lessonId: null,
            participantInfos: new Map() // userId -> {fullName, role, username}
        };

        
// WebRTC ICE config (STUN + optional TURN). Loaded from server so creds are not hardcoded in HTML.
// Server endpoint: GET /api/rtc-config
const DEFAULT_RTC_CONFIG = {
    iceServers: [
        { urls: ['stun:stun.l.google.com:19302','stun:stun1.l.google.com:19302'] }
    ]
};

let _rtcConfigCache = null;
async function getRtcConfig() {
    if (_rtcConfigCache) return _rtcConfigCache;
    try {
        const res = await fetch('/api/rtc-config', { cache: 'no-store' });
        if (!res.ok) throw new Error('rtc-config http ' + res.status);
        const cfg = await res.json();
        if (cfg && Array.isArray(cfg.iceServers)) {
            _rtcConfigCache = cfg;
            return _rtcConfigCache;
        }
    } catch (e) {
        console.warn('RTC config load failed, falling back to STUN-only:', e);
    }
    _rtcConfigCache = DEFAULT_RTC_CONFIG;
    return _rtcConfigCache;
}

// Participant info helpers (role/name for layout + attendance UI)
function setParticipantInfos(arr) {
    try {
        groupCall.participantInfos = new Map();
        (arr || []).forEach(u => {
            if (!u) return;
            groupCall.participantInfos.set(String(u.userId || u._id || ''), {
                fullName: u.fullName || u.nickname || u.username || 'User',
                username: u.username || '',
                role: (u.role || 'student').toString().toLowerCase()
            });
        });
        // update meta counters
        const sCount = Array.from(groupCall.participantInfos.values()).filter(x => x.role !== 'teacher').length;
        const tCount = Array.from(groupCall.participantInfos.values()).filter(x => x.role === 'teacher').length;
        const sm = document.getElementById('studentsMeta');
        if (sm) sm.textContent = sCount ? (sCount + ' ta') : '';
        const tm = document.getElementById('teacherStageMeta');
        if (tm) tm.textContent = tCount ? ('teacher: ' + tCount) : '';
    } catch(e) {}
}
function getUserLabel(userId) {
    const info = groupCall.participantInfos.get(String(userId));
    return info?.fullName || info?.username || (String(userId).slice(-6));
}
function isTeacher(userId) {
    const info = groupCall.participantInfos.get(String(userId));
    return (info?.role || '').toLowerCase() === 'teacher';
}

        function toggleGroupCallPanel() {
            // simple helper for demo - if overlay hidden but active, show it
            const el = document.getElementById('groupCallOverlay');
            if (el.classList.contains('hidden')) el.classList.remove('hidden');
            else el.classList.add('hidden');
        }

        function setGroupCallStatus(text) {
            const el = document.getElementById('groupCallStatus');
            if (el) el.textContent = text;
        }

        function showGroupOverlay() {
            document.getElementById('groupCallOverlay').classList.remove('hidden');
        }

        function hideGroupOverlay() {
            document.getElementById('groupCallOverlay').classList.add('hidden');
            document.getElementById('groupIncomingBox').classList.add('hidden');
        }


        // Mobile: call controls dropdown
        function toggleCallMoreMenu(){
            const m = document.getElementById('callMoreMenu');
            if(!m) return;
            m.classList.toggle('hidden');
        }
        function closeCallMoreMenu(){
            const m = document.getElementById('callMoreMenu');
            if(m) m.classList.add('hidden');
        }
        document.addEventListener('click', (e)=>{
            const btn = document.getElementById('btnCallMore');
            const menu = document.getElementById('callMoreMenu');
            if(!menu || menu.classList.contains('hidden')) return;
            if(btn && (btn===e.target || btn.contains(e.target))) return;
            if(menu===e.target || menu.contains(e.target)) return;
            closeCallMoreMenu();
        });

        function showIncomingGroupBox(metaText) {
            document.getElementById('groupIncomingMeta').textContent = metaText;
            document.getElementById('groupIncomingBox').classList.remove('hidden');
            showGroupOverlay();
            try{ if(document.getElementById('lessonTitleWrap')){ const isT = (String(currentUser?.role||'').toLowerCase()==='teacher'); document.getElementById('lessonTitleWrap').classList.toggle('hidden', !isT); } }catch(e){}
        }

        function dismissIncomingGroupCall() {
            groupCall.incoming = null;
            document.getElementById('groupIncomingBox').classList.add('hidden');
            if (!groupCall.active) hideGroupOverlay();
        }

        async function acceptIncomingGroupCall() {
            if (!groupCall.incoming) return;
            await joinGroupCall(groupCall.incoming.groupId, groupCall.incoming.callId, groupCall.incoming.callType);
            groupCall.incoming = null;
            document.getElementById('groupIncomingBox').classList.add('hidden');
        }

        function shouldInitiateOffer(localId, remoteId) {
            // deterministic tie-breaker to avoid offer glare
            return String(localId) < String(remoteId);
        }

        async function ensureLocalStream(callType) {

  if (OBSERVER_MODE) {
    // Admin/Observer: no camera/mic tracks. Receive-only.
    groupCall.localStream = null;
    return null;
  }


  // If we already have a *live* local stream, reuse it.
  // Important: after leaving a call we may have a stream object whose tracks are ended (mobile does this a lot).
  if (groupCall.localStream) {
    try {
      const tracks = groupCall.localStream.getTracks ? groupCall.localStream.getTracks() : [];
      const hasLive = tracks.some(t => t && t.readyState === 'live');
      if (hasLive) return groupCall.localStream;
    } catch(e) {}
    try { groupCall.localStream.getTracks().forEach(t=>t.stop()); } catch(e) {}
    groupCall.localStream = null;
  }
// For camera-less / mic-less devices: allow "watch-only" participation.
// We try video+audio -> audio-only -> no local tracks.
const videoConstraints = { width: 1280, height: 720 };
const audioConstraints = AUDIO_CONSTRAINTS;
try {
    const constraints = (callType === 'audio')
        ? { audio: AUDIO_CONSTRAINTS, video: false }
        : { audio: AUDIO_CONSTRAINTS, video: videoConstraints };

    groupCall.localStream = await navigator.mediaDevices.getUserMedia(constraints);
    addVideoTile(String(currentUser?._id || 'local'), groupCall.localStream, true);
    return groupCall.localStream;
} catch (err) {
    console.warn('ensureLocalStream getUserMedia failed:', err);

    // If video failed, retry audio-only (common on devices with no camera permission/camera)
    if (callType !== 'audio') {
        try {
            groupCall.localStream = await navigator.mediaDevices.getUserMedia({ audio: AUDIO_CONSTRAINTS, video: false });
            addVideoTile(String(currentUser?._id || 'local'), groupCall.localStream, true);
            return groupCall.localStream;
        } catch (err2) {
            console.warn('ensureLocalStream audio-only failed:', err2);
        }
    }

    // Final fallback: no local tracks (recv-only mode)
    groupCall.localStream = null;
    return null;
}
        }

        
        function getTileContainerFor(userId) {
            const tStage = document.getElementById('teacherStage');
            const sGrid = document.getElementById('studentsGrid');
            const uid = String(userId);
            // Teacher goes to stage; everyone else to grid
            if (isTeacher(uid)) return tStage || sGrid;
            return sGrid || tStage;
        }

        function ensureStagePlaceholder() {
            const tStage = document.getElementById('teacherStage');
            if (!tStage) return;
            if (!tStage.querySelector('.stage-placeholder')) {
                const ph = document.createElement('div');
                ph.className = 'stage-placeholder w-full h-full flex items-center justify-center text-white/70';
                ph.innerHTML = '<div class="text-center"><i class="fas fa-video-slash text-3xl mb-2"></i><div class="text-sm">O‘qituvchi video hali yo‘q</div></div>';
                tStage.appendChild(ph);
            }
        }

        function addVideoTile(userId, stream, isLocal = false) {
            const tileId = `tile_${userId}`;
            let tile = document.getElementById(tileId);

            if (!tile) {
                tile = document.createElement('div');
                tile.id = tileId;
                tile.className = "relative rounded-2xl overflow-hidden bg-black shadow border border-white/10";
                tile.innerHTML = `
                    <video id="vid_${userId}" autoplay playsinline ${isLocal ? 'muted' : ''} class="w-full h-full object-cover bg-black"></video>
                    <div class="absolute left-2 bottom-2 px-2 py-1 rounded-lg bg-black/60 text-white text-xs font-semibold">
                      ${isLocal ? 'Siz' : getUserLabel(userId)}
                    </div>
                `;
            }

            const video = tile.querySelector('video');
            if (video && stream) {
                video.srcObject = stream;
            }

            const container = getTileContainerFor(userId);
            if (container) {
                // Teacher stage wants single element; replace current stage content
                if (container.id === 'teacherStage' && isTeacher(String(userId))) {
                    container.innerHTML = '';
                    container.appendChild(tile);
                    tile.style.width = '100%';
                    tile.style.height = '100%';
                    tile.querySelector('video').style.width='100%';
                    tile.querySelector('video').style.height='100%';
                } else {
                    if (!tile.parentElement || tile.parentElement.id !== container.id) {
                        container.appendChild(tile);
                    }
                    tile.style.height = '220px';
                }
            }

            ensureStagePlaceholder();
        }

        function removeVideoTile(userId) {
            const tile = document.getElementById(`tile_${userId}`);
            if (tile) tile.remove();
            ensureStagePlaceholder();
        }

        function renderGroupCallLayout() {
            // Re-assign tiles between teacher stage and students grid based on latest participantInfos.
            const tStage = document.getElementById('teacherStage');
            const sGrid = document.getElementById('studentsGrid');
            if (!tStage || !sGrid) return;

            // Find teacher id (prefer remote teacher; fallback local if teacher)
            const entries = Array.from(groupCall.participantInfos.entries());
            let teacherId = entries.find(([id, info]) => info?.role === 'teacher')?.[0] || null;
            if (!teacherId && currentUser && (String(currentUser.role || '').toLowerCase() === 'teacher')) teacherId = String(currentUser._id);

            // Move teacher tile to stage if exists
            if (teacherId) {
                const tTile = document.getElementById(`tile_${teacherId}`);
                if (tTile) {
                    tStage.innerHTML = '';
                    tStage.appendChild(tTile);
                    tTile.style.width='100%'; tTile.style.height='100%';
                } else {
                    ensureStagePlaceholder();
                }
            } else {
                ensureStagePlaceholder();
            }

            // Ensure non-teacher tiles are in students grid
            document.querySelectorAll('[id^="tile_"]').forEach(tile => {
                const uid = tile.id.replace('tile_','');
                if (teacherId && String(uid) === String(teacherId)) return;
                if (!sGrid.contains(tile)) sGrid.appendChild(tile);
                tile.style.height = '220px';
            });
        }

        
        function updateGroupGridLayout() {
            const grid = document.getElementById('groupVideosGrid');
            if (!grid) return;
            const count = grid.children.length || 0;

            // Simple responsive columns based on participant count
            let cols = 1;
            if (count <= 1) cols = 1;
            else if (count === 2) cols = 2;
            else if (count <= 4) cols = 2;
            else if (count <= 6) cols = 3;
            else if (count <= 9) cols = 3;
            else cols = 4;

            grid.style.gridTemplateColumns = `repeat(${cols}, minmax(0, 1fr))`;
        }

function removeVideoTile(userId) {
            const tile = document.getElementById(`tile_${userId}`);
            if (tile) tile.remove();
            updateGroupGridLayout();
        }

        async function createPeer(remoteUserId) {
            if (groupCall.peers.has(remoteUserId)) return groupCall.peers.get(remoteUserId);

            const pc = new RTCPeerConnection(await getRtcConfig());

            // Add local tracks (or recv-only transceivers for observer/watch-only)
            if (groupCall.localStream) {
                groupCall.localStream.getTracks().forEach(track => pc.addTrack(track, groupCall.localStream));
            } else {
                // Modern browsers require explicit transceivers for recv-only.
                try { pc.addTransceiver('audio', { direction: 'recvonly' }); } catch(_) {}
                if (groupCall.callType !== 'audio') { try { pc.addTransceiver('video', { direction: 'recvonly' }); } catch(_) {} }
            }

            pc.onicecandidate = (event) => {
                if (event.candidate && socket && groupCall.active) {
                    socket.emit('groupCallSignal', {
                        groupId: groupCall.groupId,
                        callId: groupCall.callId,
                        to: remoteUserId,
                        type: 'ice',
                        data: event.candidate
                    });
                }
            };

            pc.ontrack = (event) => {
                const stream = event.streams[0];
                groupCall.remoteStreams.set(remoteUserId, stream);
                addVideoTile(remoteUserId, stream, false);
            };

            pc.onconnectionstatechange = () => {
                if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected' || pc.connectionState === 'closed') {
                    // cleanup will happen on leave events too
                }
            };

            groupCall.peers.set(remoteUserId, pc);
            return pc;
        }

        async function sendOffer(remoteUserId) {
            const pc = await createPeer(remoteUserId);
            const offer = await pc.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: (groupCall.callType !== 'audio') });
            await pc.setLocalDescription(offer);

            socket.emit('groupCallSignal', {
                groupId: groupCall.groupId,
                callId: groupCall.callId,
                to: remoteUserId,
                type: 'offer',
                data: offer
            });
        }

        async function handleOffer(from, offer) {
            const pc = await createPeer(from);
            await pc.setRemoteDescription(new RTCSessionDescription(offer));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);

            socket.emit('groupCallSignal', {
                groupId: groupCall.groupId,
                callId: groupCall.callId,
                to: from,
                type: 'answer',
                data: answer
            });
        }

        async function handleAnswer(from, answer) {
            const pc = groupCall.peers.get(from);
            if (!pc) return;
            await pc.setRemoteDescription(new RTCSessionDescription(answer));
        }

        async function handleIce(from, candidate) {
            const pc = groupCall.peers.get(from);
            if (!pc) return;
            try {
                await pc.addIceCandidate(new RTCIceCandidate(candidate));
            } catch (e) {
                console.error('ICE add error', e);
            }
        }

        async function startGroupVideoCall() {
            if (!currentGroup) return;
            await startGroupCall('video');
        }

        async function startGroupAudioCall() {
            if (!currentGroup) return;
            await startGroupCall('audio');
        }

        async function startGroupCall(callType) {
            if (!socket) return notify('Socket ulanmagan', 'err');
            groupCall.callType = callType;
            groupCall.groupId = groupId;

            showGroupOverlay();
            // Teacher can enter lesson topic/title
            try{
                const isT = String(currentUser?.role||'').toLowerCase()==='teacher';
                const wrap = document.getElementById('lessonTitleWrap');
                if (wrap) wrap.classList.toggle('hidden', !isT);
                const inp = document.getElementById('lessonTitleInput');
                if (inp) { inp.disabled=false; inp.readOnly=false; if(isT) setTimeout(()=>inp.focus(), 50); }
            }catch(_){ }
            document.getElementById('groupCallTitle').textContent = callType === 'audio' ? 'Group Voice Call' : 'Group Video Call';
            setGroupCallStatus('Starting...');

            try {
                await ensureLocalStream(callType);
                const lessonTitle = (document.getElementById('lessonTitleInput')?.value || '').trim();
                if (lessonTitle) { try{ document.getElementById('groupCallTitle').textContent = lessonTitle; }catch(_){} }
                socket.emit('groupCallStart', { groupId, callType, title: lessonTitle });
                /* lessonTitleInput stays editable until recording starts */
            } catch (e) {
                console.error(e);
                notify('Callni boshlashda xatolik: ' + e.message, 'err');
                cleanupGroupCallUI();
                try{ const ti=document.getElementById('lessonTitleInput'); if(ti) { ti.disabled=false; } }catch(e){}
            }
        }

        async function joinGroupCall(gid, callId, callType) {
            if (!socket) return;
            groupCall.callType = callType || 'video';
            groupCall.groupId = gid;
            groupCall.callId = callId;

            showGroupOverlay();
            document.getElementById('groupCallTitle').textContent = groupCall.callType === 'audio' ? 'Group Voice Call' : 'Group Video Call';
            try{ if(groupCall.incoming && groupCall.incoming.title) document.getElementById('groupCallTitle').textContent = groupCall.incoming.title; }catch(_){}
            setGroupCallStatus('Joining...');

            await ensureLocalStream(groupCall.callType);
            try { if (currentUser && currentUser._id) groupCall.participantInfos.set(String(currentUser._id), { role: String(currentUser.role||'').toLowerCase() }); } catch(_) {}
            socket.emit('groupCallJoin', { groupId: gid, callId });
        }

        
        // ==================== TEACHER CONTROLS (Attendance + Screen+Cam + Recording) ====================
        let _attendanceTimer = null;
        let _recorder = null;
        let _recordingChunks = [];
        let _isRecording = false;
        let _compositeCanvas = null;
        let _compositeStream = null;
        let _screenStream = null;
        let _camStream = null;
        let _compositeAnimId = null;
        let _screenShareActive = false;

        // Build a composite canvas stream for recording that works even without screen-share:
        // - If screen-share is active, canvas draws screen + PIP camera
        // - If screen-share ends, canvas falls back to camera full-frame (no black video)
        async function initCompositeCameraOnlyIfNeeded() {
            if (_compositeCanvas && _compositeStream && _camVideoEl) return;
            const base = groupCall._prevLocalStream || groupCall.localStream;
            // Camera source (prefer already-open camera track)
            let camStream = null;
            if (base && base.getVideoTracks && base.getVideoTracks().length) {
                camStream = new MediaStream([base.getVideoTracks()[0]]);
            } else {
                // device might be watch-only; try to open camera if available (ignore failure)
                camStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false }).catch(() => null);
            }
            // Audio source (prefer already-open mic)
            let micTrack = null;
            if (base && base.getAudioTracks && base.getAudioTracks().length) micTrack = base.getAudioTracks()[0];
            if (!micTrack) {
                const micStream = await navigator.mediaDevices.getUserMedia({ audio: AUDIO_CONSTRAINTS, video: false }).catch(() => null);
                micTrack = micStream?.getAudioTracks?.()[0] || null;
            }

            _camStream = camStream;
            const camVideo = document.createElement('video');
            camVideo.srcObject = camStream || new MediaStream();
            camVideo.muted = true;
            try { await camVideo.play(); } catch(_) {}
            _camVideoEl = camVideo;

            const canvas = document.createElement('canvas');
            canvas.width = 1280;
            canvas.height = 720;
            _compositeCanvas = canvas;
            const ctx = canvas.getContext('2d');

            // draw loop reuses the same logic as screen+cam (screen may be null)
            const isScreenLive = () => {
                const t = _screenStream?.getVideoTracks?.()[0];
                return !!t && t.readyState === 'live';
            };

            const draw = () => {
                try {
                    const W = canvas.width, H = canvas.height;
                    ctx.clearRect(0, 0, W, H);
                    ctx.fillStyle = 'black';
                    ctx.fillRect(0, 0, W, H);

                    const mainH = Math.floor(H * 0.72);
                    const bottomY = mainH;
                    const pad = 10;

                    const screenOk = _screenShareActive && isScreenLive() && _screenVideoEl && _screenVideoEl.readyState >= 2;
                    let mainEl = null;
                    if (screenOk) {
                        mainEl = _screenVideoEl;
                    } else {
                        const ts = document.getElementById('teacherStageVideo') || document.querySelector('#teacherStage video');
                        if (ts && ts.readyState >= 2) mainEl = ts;
                        else if (_camVideoEl && _camVideoEl.readyState >= 2) mainEl = _camVideoEl;
                    }

                    if (mainEl) {
                        const vw = mainEl.videoWidth || W;
                        const vh = mainEl.videoHeight || mainH;
                        const scale = Math.max(W / vw, mainH / vh);
                        const dw = vw * scale;
                        const dh = vh * scale;
                        ctx.drawImage(mainEl, (W - dw) / 2, (mainH - dh) / 2, dw, dh);
                    } else {
                        ctx.fillStyle = '#111';
                        ctx.fillRect(0, 0, W, mainH);
                        ctx.fillStyle = 'white';
                        ctx.font = '22px sans-serif';
                        ctx.fillText("Video yo'q", 20, 40);
                    }

                    const vids = Array.from(document.querySelectorAll('#groupVideosGrid video'))
                        .filter(v => v && v !== mainEl && v.readyState >= 2);

                    const areaH = H - mainH;
                    const cols = Math.min(3, Math.max(1, vids.length));
                    const rows = Math.ceil(vids.length / cols) || 1;
                    const tileW = Math.floor((W - pad * (cols + 1)) / cols);
                    const tileH = Math.floor((areaH - pad * (rows + 1)) / rows);

                    let i = 0;
                    for (const v of vids) {
                        const r = Math.floor(i / cols);
                        const c = i % cols;
                        const x = pad + c * (tileW + pad);
                        const y = bottomY + pad + r * (tileH + pad);

                        const vw = v.videoWidth || tileW;
                        const vh = v.videoHeight || tileH;
                        const scale = Math.max(tileW / vw, tileH / vh);
                        const dw = vw * scale;
                        const dh = vh * scale;
                        ctx.drawImage(v, x + (tileW - dw) / 2, y + (tileH - dh) / 2, dw, dh);
                        i++;
                    }
                } catch (_) {}
                _compositeAnimId = requestAnimationFrame(draw);
            };
            draw();

            const out = new MediaStream();
            const [vTrack] = canvas.captureStream(30).getVideoTracks();
            if (vTrack) out.addTrack(vTrack);
            if (micTrack) out.addTrack(micTrack);
            _compositeStream = out;
        }
            let _screenVideoEl = null;
        let _camVideoEl = null;

        function updateTeacherControls() {
            const isMeTeacher = String(currentUser?.role || '').toLowerCase() === 'teacher';
            const hasLesson = !!groupCall.lessonId;
            const isVideo = (groupCall.callType !== 'audio');
            const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

            // Desktop buttons
            const btnScreen = document.getElementById('btnScreen');
            const btnRec = document.getElementById('btnRecord');
            const btnAtt = document.getElementById('btnAttendance');
            const btnSw = document.getElementById('btnSwitchCam');

            // Mobile menu items
            const mScreen = document.getElementById('mBtnScreen');
            const mRec = document.getElementById('mBtnRecord');
            const mAtt = document.getElementById('mBtnAttendance');
            const mSw = document.getElementById('mBtnSwitchCam');

            const showTeacher = (isMeTeacher && groupCall.active && hasLesson);
            if (btnScreen) btnScreen.classList.toggle('hidden', !showTeacher);
            if (btnRec) btnRec.classList.toggle('hidden', !showTeacher);
            if (btnAtt) btnAtt.classList.toggle('hidden', !showTeacher);

            if (mScreen) mScreen.classList.toggle('hidden', !showTeacher);
            if (mRec) mRec.classList.toggle('hidden', !showTeacher);
            if (mAtt) mAtt.classList.toggle('hidden', !showTeacher);

            const showSwitch = (isVideo && isMobile && groupCall.active);
            if (btnSw) btnSw.classList.toggle('hidden', !showSwitch);
            if (mSw) mSw.classList.toggle('hidden', !showSwitch);
        

            // Lesson title input (teacher only) + prevent 'can't type' bug
            const lt = document.getElementById('lessonTitleWrap');
            if (lt) lt.classList.toggle('hidden', !(isMeTeacher && groupCall.active));
            const lti = document.getElementById('lessonTitleInput');
            if (lti) { lti.disabled = false; lti.readOnly = false; }

        }

        function toggleAttendancePanel(show) {
            const p = document.getElementById('attendancePanel');
            if (!p) return;
            const isMeTeacher = String(currentUser?.role || '').toLowerCase() === 'teacher';
            if (!isMeTeacher) return;
            if (show === true) p.classList.remove('hidden');
            else if (show === false) p.classList.add('hidden');
            else p.classList.toggle('hidden');

            if (!p.classList.contains('hidden')) startAttendanceLoop();
            else stopAttendanceLoop();
        }

        function stopAttendanceLoop() {
            if (_attendanceTimer) clearInterval(_attendanceTimer);
            _attendanceTimer = null;
        }

        async function startAttendanceLoop() {
            stopAttendanceLoop();
            await refreshAttendance();
            _attendanceTimer = setInterval(refreshAttendance, 5000);
        }

        function fmtTime(dt) {
            if (!dt) return '—';
            const d = new Date(dt);
            return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        function fmtDur(sec) {
            sec = Number(sec||0);
            const m = Math.floor(sec/60);
            const s = sec%60;
            return `${m}m ${String(s).padStart(2,'0')}s`;
        }

        async function refreshAttendance() {
            try {
                const hint = document.getElementById('attendanceHint');
                if (hint) hint.textContent = 'Yangilanmoqda...';
                if (!groupCall.lessonId) return;

                const token = localStorage.getItem('token');
                const res = await fetch(`/api/group-lessons/${groupCall.lessonId}/attendance`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!res.ok) throw new Error('attendance http ' + res.status);
                const data = await res.json();

                const joinedBox = document.getElementById('attendanceJoined');
                const absentBox = document.getElementById('attendanceAbsent');
                if (joinedBox) joinedBox.innerHTML = '';
                if (absentBox) absentBox.innerHTML = '';

                (data.joined || []).forEach(r => {
                    const div = document.createElement('div');
                    div.className = 'p-2 rounded-xl bg-white/10 border border-white/10 text-white';
                    div.innerHTML = `
                      <div class="font-semibold text-sm">${r.fullName || 'Talaba'}</div>
                      <div class="text-xs text-white/70">Kirdi: ${fmtTime(r.joinedAt)} • Chiqdi: ${fmtTime(r.leftAt)} • Davomiylik: ${fmtDur(r.durationSec)}</div>
                    `;
                    joinedBox && joinedBox.appendChild(div);
                });

                (data.absent || []).forEach(r => {
                    const div = document.createElement('div');
                    div.className = 'p-2 rounded-xl bg-white/5 border border-white/10 text-white/90';
                    div.innerHTML = `<div class="font-semibold text-sm">${r.fullName || 'Talaba'}</div><div class="text-xs text-white/60">Kirmadi</div>`;
                    absentBox && absentBox.appendChild(div);
                });

                if (hint) hint.textContent = `Kirdi: ${(data.joined||[]).length} • Kirmadi: ${(data.absent||[]).length}`;
            } catch (e) {
                console.warn('attendance refresh failed', e);
                const hint = document.getElementById('attendanceHint');
                if (hint) hint.textContent = 'Davomatni olishda xatolik';
            }
        }

        async function startScreenWithCam() {
    // Teacher: replace outgoing video with screen (and keep camera as PIP locally), without breaking camera-only mode.
    if (!groupCall.active) return;
    if (String(currentUser?.role || '').toLowerCase() !== 'teacher') return;

    // SFU (LiveKit): native screenshare, no camera freeze when switching windows.
    try{
        if (groupCall.lk?.connected && groupCall.lk?.room) {
            await groupCall.lk.room.localParticipant.setScreenShareEnabled(true);
            setGroupCallStatus('Screen share (SFU) ✅');
            return;
        }
    }catch(e){ console.warn('LiveKit screenshare failed, fallback to mesh', e); }


    try {
        // 1) Ask for screen
        let screenStream;
        try {
            screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
        } catch (e1) {
            // Many browsers don't allow system audio capture; retry without audio
            try {
                screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });
            } catch (e2) {
                if (e2 && (e2.name === 'NotAllowedError' || e2.name === 'SecurityError')) {
                    // User denied: don't change anything, keep camera on stage
                    console.warn('Screen share denied', e2);
                    setGroupCallStatus('Screen share bekor qilindi');
                    return;
                }
                throw e2;
            }
        }

        // 2) Camera stream for local PIP (optional)
        const camStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false }).catch(() => null);

        // 3) Mic audio (reliable)
        const micStream = await navigator.mediaDevices.getUserMedia({ audio: AUDIO_CONSTRAINTS, video: false }).catch(() => null);

        _screenStream = screenStream;

        // When user stops sharing, revert drawing to camera-only (prevents black recording)
        try {
            const t = _screenStream?.getVideoTracks?.()[0];
            if (t) {
                t.onended = () => {
                    _screenShareActive = false;
                    try { _screenStream?.getTracks?.().forEach(tr => tr.stop()); } catch(_) {}
                    _screenStream = null;
                    _screenVideoEl = null;
                    setGroupCallStatus('Screen share tugadi');
                };
            }
        } catch(_) {}
        _camStream = camStream;

        // 4) Composite: draw screen + small camera overlay
        const screenVideo = document.createElement('video');
        screenVideo.srcObject = _screenStream;
        screenVideo.muted = true;
        await screenVideo.play();
        _screenVideoEl = screenVideo;

        let camVideo = null;
        if (_camStream) {
            camVideo = document.createElement('video');
            camVideo.srcObject = _camStream;
            camVideo.muted = true;
            await camVideo.play();
        }
        _camVideoEl = camVideo;

        const canvas = document.createElement('canvas');
        canvas.width = 1280;
        canvas.height = 720;
        _compositeCanvas = canvas;
        const ctx = canvas.getContext('2d');

        _screenShareActive = true;
        const isScreenLive = () => {
            const t = _screenStream?.getVideoTracks?.()[0];
            return !!t && t.readyState === 'live';
        };

        const draw = () => {
            try {
                const screenOk = _screenShareActive && isScreenLive() && screenVideo && screenVideo.readyState >= 2;
                const camOk = camVideo && camVideo.readyState >= 2;

                if (screenOk) {
                    // Main: screen
                    ctx.drawImage(screenVideo, 0, 0, canvas.width, canvas.height);

                    // PIP: camera
                    if (camOk) {
                        const pipW = Math.round(canvas.width * 0.22);
                        const pipH = Math.round(pipW * (9 / 16));
                        const margin = 16;
                        const x = canvas.width - pipW - margin;
                        const y = margin;
                        ctx.save();
                        const r = 14;
                        ctx.beginPath();
                        ctx.moveTo(x + r, y);
                        ctx.lineTo(x + pipW - r, y);
                        ctx.quadraticCurveTo(x + pipW, y, x + pipW, y + r);
                        ctx.lineTo(x + pipW, y + pipH - r);
                        ctx.quadraticCurveTo(x + pipW, y + pipH, x + pipW - r, y + pipH);
                        ctx.lineTo(x + r, y + pipH);
                        ctx.quadraticCurveTo(x, y + pipH, x, y + pipH - r);
                        ctx.lineTo(x, y + r);
                        ctx.quadraticCurveTo(x, y, x + r, y);
                        ctx.closePath();
                        ctx.clip();
                        ctx.drawImage(camVideo, x, y, pipW, pipH);
                        ctx.restore();
                    }
                } else if (camOk) {
                    // Screen ended -> fallback to camera full-frame (prevents black recording)
                    ctx.drawImage(camVideo, 0, 0, canvas.width, canvas.height);
                } else {
                    // No usable video
                    ctx.fillStyle = 'black';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'white';
                    ctx.font = '22px sans-serif';
                    ctx.fillText('Video yo\'q', 20, 40);
                }
            } catch (_) {}
            _compositeAnimId = requestAnimationFrame(draw);
        };
        draw();

        // 5) Build outgoing stream: video from canvas, audio from mic/system
        const out = new MediaStream();

        const [vTrack] = canvas.captureStream(30).getVideoTracks();
        if (vTrack) out.addTrack(vTrack);

        // Prefer mic audio
        const micTrack = micStream?.getAudioTracks?.()[0];
        if (micTrack) out.addTrack(micTrack);

        // If system audio exists and mic does not, add it
        if (!micTrack) {
            const sysTrack = _screenStream.getAudioTracks()[0];
            if (sysTrack) out.addTrack(sysTrack);
        }

        _compositeStream = out;

        // 6) Replace outgoing tracks for all peers (do NOT touch if no peers yet)
        // Keep a reference so stopComposite() can revert.
        groupCall._prevLocalStream = groupCall.localStream || null;
        groupCall.localStream = out;

        // Update local preview (teacher sees what's being sent)
        addVideoTile(currentUser?._id, out, true);
        renderGroupCallLayout();

        for (const [uid, pc] of groupCall.peers.entries()) {
            const senders = pc.getSenders();
            const vs = senders.find(s => s.track && s.track.kind === 'video');
            if (vs && vTrack) await vs.replaceTrack(vTrack);

            const aTrack = out.getAudioTracks()[0];
            const as = senders.find(s => s.track && s.track.kind === 'audio');
            if (as && aTrack) await as.replaceTrack(aTrack);
        }

        // Auto-stop when screen share ends
        const st = _screenStream.getVideoTracks()[0];
        if (st) st.onended = () => {
            // If recording is active, keep the canvas stream alive and continue with camera
            _screenShareActive = false;
            try { _screenStream && _screenStream.getTracks().forEach(t => t.stop()); } catch (_) {}
            _screenStream = null;
            if (_isRecording) {
                setGroupCallStatus('Screen tugadi, camera yozuvi davom etadi');
                return;
            }
            try { stopComposite(); } catch (_) {}
        };

        groupCall.isScreenSharing = true;
        updateCallControlUI();
        setGroupCallStatus('Teacher mode: Screen + Cam');
    } catch (e) {
        console.error('startScreenWithCam', e);
        notify('Ekran ulashishda xatolik: ' + (e?.message || e), 'err');
    }
}

        function stopComposite() {
    try {
        // Stop screen/cam overlay inputs
        _screenStream && _screenStream.getTracks().forEach(t => t.stop());
        _camStream && _camStream.getTracks().forEach(t => t.stop());
    } catch(e) {}

    // Stop animation loop
    try { if (_compositeAnimId) cancelAnimationFrame(_compositeAnimId); } catch(_) {}
    _compositeAnimId = null;
    _screenShareActive = false;
    groupCall.isScreenSharing = false;
    updateCallControlUI();

    // Stop canvas stream tracks (otherwise recording can keep a dead black track alive)
    try { _compositeStream && _compositeStream.getTracks().forEach(t => t.stop()); } catch(_) {}

    _screenStream = null;
    _camStream = null;
    _screenVideoEl = null;
    _camVideoEl = null;
    _compositeCanvas = null;
    _compositeStream = null;

    // Revert outgoing tracks back to previous local stream (camera mode)
    const prev = groupCall._prevLocalStream || null;
    if (prev) {
        const prevV = prev.getVideoTracks()[0] || null;
        const prevA = prev.getAudioTracks()[0] || null;
        groupCall.localStream = prev;
        groupCall._prevLocalStream = null;

        // Update preview back to camera
        addVideoTile(currentUser?._id, prev, true);
        renderGroupCallLayout();

        // Replace tracks for existing peers
        (async () => {
            try {
                for (const [uid, pc] of groupCall.peers.entries()) {
                    const senders = pc.getSenders();
                    const vs = senders.find(s => s.track && s.track.kind === 'video');
                    if (vs && prevV) await vs.replaceTrack(prevV);
                    const as = senders.find(s => s.track && s.track.kind === 'audio');
                    if (as && prevA) await as.replaceTrack(prevA);
                }
            } catch(_) {}
        })();

        setGroupCallStatus('Camera mode');
    }
}

                async function toggleRecording() {
            try {
                if (String(currentUser?.role || '').toLowerCase() !== 'teacher') return;
                if (!groupCall.lessonId) return;

                // Stop
                if (_isRecording && _recorder) {
                    try { _recorder.stop(); } catch(_) {}
                    return;
                }

                let baseStream = groupCall.localStream;
                if (!baseStream) return notify('Avval callni boshlang, keyin recording yoqing.', 'warn');

                // Recording always uses a composite canvas stream:
                // - camera-only works everywhere MediaRecorder works (including mobile Chrome)
                // - if teacher shares screen later, composite will automatically show screen + PIP camera
                
                // Save lesson topic/mode before recording starts (so Group Lessons shows it)
                const _title = (document.getElementById('lessonTitleInput')?.value || '').trim();
                const _mode = groupCall.isScreenSharing ? 'screen' : 'camera';
                if (_title) { try{ await updateLessonMeta(groupCall.lessonId, { title: _title, mode: _mode }); }catch(_){} }
                try{ const ti=document.getElementById('lessonTitleInput'); if(ti) ti.disabled = true; }catch(e){}
await initCompositeCameraOnlyIfNeeded();
                baseStream = _compositeStream || baseStream;
if (typeof MediaRecorder === 'undefined') {
                    // Some browsers (especially older iOS Safari) cannot record via MediaRecorder.
                    // Client-side recording is impossible there without a media server/SFU recorder.
                    return notify('Bu brauzer Recording-ni qo\'llab-quvvatlamaydi (MediaRecorder yo\'q). Tavsiya: Android/PC Chrome. iOS Safari uchun server-side recorder kerak.', 'warn');
                }

                _recordingChunks = [];

                // 1) Try direct stream recording with best supported mime
                const mimeCandidates = [
                    'video/webm;codecs=vp9,opus',
                    'video/webm;codecs=vp8,opus',
                    'video/webm'
                ];
                const pickMime = () => {
                    try {
                        if (!MediaRecorder.isTypeSupported) return '';
                        for (const mt of mimeCandidates) {
                            if (MediaRecorder.isTypeSupported(mt)) return mt;
                        }
                    } catch(_) {}
                    return '';
                };

                // 2) Fallback: canvas composition recording (works on more devices when direct stream fails)
                const makeCanvasRecorderStream = async (stream) => {
                    const vEl = document.getElementById('localVideo') || document.querySelector('video#localVideo');
                    const stageEl = document.getElementById('teacherStageVideo') || document.querySelector('video#teacherStageVideo') || null;

                    // Helper: safe video dimensions
                    const getVidWH = (el) => {
                        const w = Number(el?.videoWidth || 0);
                        const h = Number(el?.videoHeight || 0);
                        if (w > 0 && h > 0) return { w, h };
                        // fallback to track settings
                        const vt = stream?.getVideoTracks?.()[0];
                        const st = vt?.getSettings?.() || {};
                        const sw = Number(st.width || 0), sh = Number(st.height || 0);
                        if (sw > 0 && sh > 0) return { w: sw, h: sh };
                        return { w: 1280, h: 720 };
                    };

                    // Choose main element for sizing
                    const mainElForSize = (stageEl && stageEl.readyState >= 2) ? stageEl : (vEl && vEl.readyState >= 2 ? vEl : stageEl || vEl);
                    const base = getVidWH(mainElForSize);

                    // Canvas size: keep native orientation (portrait stays portrait). Limit long side to 1280 (don’t upscale).
                    const maxSide = 1280;
                    const scale = Math.min(1, maxSide / Math.max(base.w, base.h));
                    const cw = Math.max(2, Math.round((base.w * scale) / 2) * 2);
                    const ch = Math.max(2, Math.round((base.h * scale) / 2) * 2);

                    const canvas = document.createElement('canvas');
                    canvas.width = cw;
                    canvas.height = ch;
                    canvas.style.position = 'fixed';
                    canvas.style.left = '-9999px';
                    canvas.style.top = '-9999px';
                    document.body.appendChild(canvas);
                    const ctx = canvas.getContext('2d', { alpha: false });

                    const drawContain = (srcEl, dx, dy, dw, dh, flipX=false) => {
                        if (!srcEl || srcEl.readyState < 2) return;
                        const sw = srcEl.videoWidth || 0;
                        const sh = srcEl.videoHeight || 0;
                        if (!sw || !sh) return;

                        // contain (letterbox)
                        const sAR = sw / sh;
                        const dAR = dw / dh;
                        let rw, rh, rx, ry;
                        if (sAR > dAR) {
                            rw = dw;
                            rh = dw / sAR;
                            rx = dx;
                            ry = dy + (dh - rh) / 2;
                        } else {
                            rh = dh;
                            rw = dh * sAR;
                            rx = dx + (dw - rw) / 2;
                            ry = dy;
                        }

                        ctx.save();
                        if (flipX) {
                            ctx.translate(rx + rw, ry);
                            ctx.scale(-1, 1);
                            ctx.drawImage(srcEl, 0, 0, rw, rh);
                        } else {
                            ctx.drawImage(srcEl, rx, ry, rw, rh);
                        }
                        ctx.restore();
                    };

                    const drawCover = (srcEl, dx, dy, dw, dh, flipX=false) => {
                        if (!srcEl || srcEl.readyState < 2) return;
                        const sw = srcEl.videoWidth || 0;
                        const sh = srcEl.videoHeight || 0;
                        if (!sw || !sh) return;

                        // cover (crop)
                        const sAR = sw / sh;
                        const dAR = dw / dh;
                        let sx=0, sy=0, sww=sw, shh=sh;
                        if (sAR > dAR) {
                            // crop left/right
                            sww = Math.round(sh * dAR);
                            sx = Math.round((sw - sww) / 2);
                        } else {
                            // crop top/bottom
                            shh = Math.round(sw / dAR);
                            sy = Math.round((sh - shh) / 2);
                        }

                        ctx.save();
                        if (flipX) {
                            ctx.translate(dx + dw, dy);
                            ctx.scale(-1, 1);
                            ctx.drawImage(srcEl, sx, sy, sww, shh, 0, 0, dw, dh);
                        } else {
                            ctx.drawImage(srcEl, sx, sy, sww, shh, dx, dy, dw, dh);
                        }
                        ctx.restore();
                    };

                    const draw = () => {
                        try {
                            ctx.fillStyle = '#000';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);

                            // Main: stage if exists else camera
                            const main = (stageEl && stageEl.readyState >= 2) ? stageEl : vEl;
                            const flipMain = (!stageEl && (groupCall?.facingMode === 'user')); // unmirror selfie in recording
                            drawContain(main, 0, 0, canvas.width, canvas.height, flipMain);

                            // PiP: camera at top-right (cover for nice look, but keeps aspect)
                            if (vEl && vEl.readyState >= 2) {
                                const w = Math.round(canvas.width * 0.28);
                                const h = Math.round(canvas.height * 0.28);
                                const pad = Math.max(10, Math.round(Math.min(canvas.width, canvas.height) * 0.02));
                                const x = canvas.width - w - pad;
                                const y = pad;
                                const r = 16;

                                ctx.save();
                                ctx.beginPath();
                                ctx.moveTo(x+r, y);
                                ctx.arcTo(x+w, y, x+w, y+h, r);
                                ctx.arcTo(x+w, y+h, x, y+h, r);
                                ctx.arcTo(x, y+h, x, y, r);
                                ctx.arcTo(x, y, x+w, y, r);
                                ctx.closePath();
                                ctx.clip();

                                const flipPip = (groupCall?.facingMode === 'user'); // unmirror selfie
                                drawCover(vEl, x, y, w, h, flipPip);

                                // border
                                ctx.lineWidth = 2;
                                ctx.strokeStyle = 'rgba(255,255,255,0.25)';
                                ctx.stroke();
                                ctx.restore();
                            }
                        } catch(_) {}
                        window._canvasRecRaf = requestAnimationFrame(draw);
                    };

                    if (window._canvasRecRaf) { try{ cancelAnimationFrame(window._canvasRecRaf); }catch(_){} }
                    window._canvasRecRaf = requestAnimationFrame(draw);

                    const canvasStream = canvas.captureStream(24); // smoother than 15fps on phones
                    const outTracks = [];

                    // video track from canvas
                    const cVideo = canvasStream.getVideoTracks()[0];
                    if (cVideo) outTracks.push(cVideo);

                    // audio from base stream (mic)
                    const aTrack = (stream.getAudioTracks && stream.getAudioTracks()[0]) ? stream.getAudioTracks()[0] : null;
                    if (aTrack) outTracks.push(aTrack);

                    // cleanup hook
                    window._canvasRecCleanup = () => {
                        try { cancelAnimationFrame(window._canvasRecRaf); } catch(_) {}
                        try { canvas.remove(); } catch(_) {}
                        try { window._canvasRecRaf = null; } catch(_) {}
                    };

                    return new MediaStream(outTracks);
                };;

                let mimeType = pickMime();
                let recordingStream = baseStream;

                // Some devices fail when recording a stream that contains a screen track from getDisplayMedia + camera, so we fallback to canvas
                let useCanvasFallback = false;

                try {
                    _recorder = new MediaRecorder(recordingStream, mimeType ? { mimeType } : undefined);
                } catch (e) {
                    useCanvasFallback = true;
                }

                if (useCanvasFallback) {
                    recordingStream = await makeCanvasRecorderStream(baseStream);
                    try {
                        _recorder = new MediaRecorder(recordingStream, mimeType ? { mimeType } : undefined);
                    } catch (e2) {
                        // last resort: no mimeType
                        _recorder = new MediaRecorder(recordingStream);
                    }
                }

                _recorder.ondataavailable = (ev) => {
                    try {
                        if (ev.data && ev.data.size > 0) _recordingChunks.push(ev.data);
                    } catch(_) {}
                };

                _recorder.onstop = async () => {
                    try {
                        _isRecording = false;
                        const btn = document.getElementById('btnRecord');
                        if (btn) {
                            btn.classList.remove('bg-red-600');
                            btn.classList.add('bg-white/10');
                            btn.innerHTML = '<i class="fas fa-circle"></i>';
                        }
                        updateCallControlUI();

                        // canvas cleanup
                        if (window._canvasRecCleanup) window._canvasRecCleanup();

                        // assemble + upload
                        const blob = new Blob(_recordingChunks, { type: (_recorder && _recorder.mimeType) ? _recorder.mimeType : 'video/webm' });
                        _recordingChunks = [];
                        await uploadRecording(blob);
                        try{ const ti=document.getElementById('lessonTitleInput'); if(ti) ti.disabled = false; }catch(e){}
                    } catch (e) {
                        console.error('Recording stop/upload error:', e);
                        notify('Recording saqlashda xatolik: ' + (e?.message || e) + ' (keyin avtomatik urinamiz)', 'warn');
                    }
                };

                _recorder.onerror = (e) => {
                    console.error('MediaRecorder error', e);
                    notify('Recording xatolik: ' + (e?.error?.message || e?.message || e), 'err');
                };

                // start
                _recorder.start(1000); // 1s chunks
                _isRecording = true;

                const btn = document.getElementById('btnRecord');
                if (btn) {
                    btn.classList.remove('bg-white/10');
                    btn.classList.add('bg-red-600');
                    btn.innerHTML = '<i class="fas fa-stop"></i>';
                }
                updateCallControlUI();
            } catch (e) {
                console.error('toggleRecording error:', e);
                notify('Recording xatolik: ' + (e?.message || e), 'err');
            }
        }

        async function autoStartRecordingIfNeeded() {
            try {
                if (OBSERVER_MODE) return;
                if (String(currentUser?.role || '').toLowerCase() !== 'teacher') return;
                if (!groupCall.active || !groupCall.lessonId) return;
                if (_isRecording) return;
                await toggleRecording();
            } catch (e) {
                console.warn('autoStartRecordingIfNeeded failed', e);
            }
        }

        function updateRecordButton() {
            const btn = document.getElementById('btnRecord');
            if (!btn) return;
            if (_isRecording) {
                btn.classList.remove('bg-white/10');
                btn.classList.add('bg-red-600');
                btn.innerHTML = '<i class="fas fa-stop"></i>';
            } else {
                btn.classList.add('bg-white/10');
                btn.classList.remove('bg-red-600');
            }
        }

        async function uploadRecording(blob) {
            // Teacher-only UX: show upload progress % after recording stops
            const isTeacher = String(currentUser?.role || '').toLowerCase() === 'teacher';
            const overlay = document.getElementById('uploadOverlay');
            const bar = document.getElementById('uploadBar');
            const pct = document.getElementById('uploadPercent');

            const showOverlay = () => {
                if (!isTeacher) return;
                try{
                    if (bar) bar.style.width = '0%';
                    if (pct) pct.textContent = '0%';
                    if (overlay) { overlay.classList.remove('hidden'); overlay.classList.add('flex'); }
                }catch(_){}
            };
            const hideOverlay = () => {
                if (!isTeacher) return;
                try{
                    if (overlay) { overlay.classList.add('hidden'); overlay.classList.remove('flex'); }
                }catch(_){}
            };

            try {
                const token = localStorage.getItem('token');
                const fd = new FormData();
                const lessonId = groupCall.lessonId;
                const filename = `lesson_${lessonId}.webm`;
                fd.append('recording', blob, filename);
                const title = (document.getElementById('lessonTitleInput')?.value || '').trim();
                if (title) fd.append('title', title);

                // Use XHR to get real upload progress
                showOverlay();

                await new Promise((resolve, reject) => {
                    const xhr = new XMLHttpRequest();
                    xhr.open('POST', `/api/group-lessons/${lessonId}/recording`, true);
                    xhr.setRequestHeader('Authorization', `Bearer ${token}`);

                    xhr.upload.onprogress = (e) => {
                        try{
                            if (!e.lengthComputable) return;
                            const p = Math.max(0, Math.min(100, Math.round((e.loaded / e.total) * 100)));
                            if (bar) bar.style.width = p + '%';
                            if (pct) pct.textContent = p + '%';
                        }catch(_){}
                    };

                    xhr.onload = () => {
                        if (xhr.status >= 200 && xhr.status < 300) resolve(true);
                        else reject(new Error('upload http ' + xhr.status));
                    };
                    xhr.onerror = () => reject(new Error('network upload error'));
                    xhr.send(fd);
                });

                hideOverlay();
                notify('Dars yozuvi saqlandi ✅', 'ok');
                try { await retryQueuedRecordings(); } catch(_){}
            } catch (e) {
                console.error('uploadRecording', e);
                hideOverlay();

                // Queue for automatic retry (IndexedDB)
                try{
                    const lessonId = groupCall.lessonId;
                    const title = (document.getElementById('lessonTitleInput')?.value || '').trim();
                    await idbLessonQueue.put({
                        id: `${lessonId}_${Date.now()}`,
                        lessonId,
                        title,
                        blob,
                        token: localStorage.getItem('token') || '',
                        filename: `lesson_${lessonId}.webm`,
                        ts: Date.now()
                    });
                }catch(_){}

                notify('Yozuv yuklanmadi — internet bo‘lsa avtomatik saqlanadi. (Queue) ⚡', 'warn');
            }
        }
function toggleSpeaker() {
            groupCall.speakerMuted = !groupCall.speakerMuted;
            // Mute/unmute all remote video elements (audio output).
            document.querySelectorAll('#teacherStage video, #studentsGrid video').forEach(v => {
                // keep local muted always
                if (v.id && v.id.startsWith('vid_local')) return;
                v.muted = !!groupCall.speakerMuted;
                v.volume = groupCall.speakerMuted ? 0 : 1;
            });
            const b = document.getElementById('btnSpeaker');
            if (b) b.innerHTML = groupCall.speakerMuted ? '<i class="fas fa-volume-mute"></i>' : '<i class="fas fa-volume-up"></i>';
            updateCallControlUI();
        }


function updateCallControlUI(){
            const role = String(currentUser?.role||'').toLowerCase();
            const hideStudentToggles = (role === 'student');
            const micOn = !groupCall.muted;
            const camOn = !groupCall.cameraOff;
            const spkOn = !groupCall.speakerMuted;
            const recOn = !!window._isRecording;
            const scrOn = !!groupCall.isScreenSharing;

            const setBtn = (id, on) => {
                const b = document.getElementById(id);
                if (!b) return;
                b.classList.toggle('ctrl-active', !!on);
                b.classList.toggle('ctrl-off', !on);
                b.setAttribute('aria-pressed', String(!!on));
            };
            // Students must not have UI to turn off camera/mic
            if (hideStudentToggles) {
                ['btnMute','btnCam','mBtnMute','mBtnCam'].forEach(id=>{ const b=document.getElementById(id); if(b) b.classList.add('hidden'); });
            } else {
                ['btnMute','btnCam','mBtnMute','mBtnCam'].forEach(id=>{ const b=document.getElementById(id); if(b) b.classList.remove('hidden'); });
            }


            // top buttons
            setBtn('btnMute', micOn);
            setBtn('btnCam', camOn);
            setBtn('btnSpeaker', spkOn);
            if (document.getElementById('btnRecord')) setBtn('btnRecord', recOn);
            if (document.getElementById('btnScreen')) setBtn('btnScreen', scrOn);

            // mobile menu icons follow state
            const swapIcon = (btnId, html) => {
                const b = document.getElementById(btnId);
                if (!b) return;
                const i = b.querySelector('i');
                if (i) i.outerHTML = html;
            };
            swapIcon('mBtnMute', micOn ? '<i class="fas fa-microphone w-5 text-center"></i>' : '<i class="fas fa-microphone-slash w-5 text-center"></i>');
            swapIcon('mBtnCam',  camOn ? '<i class="fas fa-video w-5 text-center"></i>' : '<i class="fas fa-video-slash w-5 text-center"></i>');
            swapIcon('mBtnSpeaker', spkOn ? '<i class="fas fa-volume-up w-5 text-center"></i>' : '<i class="fas fa-volume-mute w-5 text-center"></i>');

            const recBtn = document.getElementById('mBtnRecord');
            if (recBtn) {
                const i = recBtn.querySelector('i');
                if (i) i.className = recOn ? 'fas fa-stop w-5 text-center' : 'fas fa-circle w-5 text-center';
            }
            const scrBtn = document.getElementById('mBtnScreen');
            if (scrBtn) {
                const i = scrBtn.querySelector('i');
                if (i) i.className = scrOn ? 'fas fa-display w-5 text-center' : 'fas fa-desktop w-5 text-center';
            }
        }

function toggleMute() {
            const role = String(currentUser?.role||'').toLowerCase();
            if (role === 'student') return notify("Talabalarda mikrofonni o'chirish ruxsat yo'q", 'info');
            if (OBSERVER_MODE) return notify('Observer mode: boshqaruv yo\'q', 'info');

            if (!groupCall.localStream) return;
            groupCall.muted = !groupCall.muted;
            groupCall.localStream.getAudioTracks().forEach(t => t.enabled = !groupCall.muted);
            const btn = document.getElementById('btnMute');
            btn.innerHTML = groupCall.muted ? '<i class="fas fa-microphone-slash"></i>' : '<i class="fas fa-microphone"></i>';
            updateCallControlUI();
        }

        function toggleCamera() {
            const role = String(currentUser?.role||'').toLowerCase();
            if (role === 'student') return notify("Talabalarda kamerani o'chirish ruxsat yo'q", 'info');
            if (OBSERVER_MODE) return notify('Observer mode: boshqaruv yo\'q', 'info');

            if (!groupCall.localStream) return;
            groupCall.cameraOff = !groupCall.cameraOff;
            groupCall.localStream.getVideoTracks().forEach(t => t.enabled = !groupCall.cameraOff);
            const btn = document.getElementById('btnCam');
            btn.innerHTML = groupCall.cameraOff ? '<i class="fas fa-video-slash"></i>' : '<i class="fas fa-video"></i>';
            updateCallControlUI();
        }

        async function switchCamera(){
            try{
                if (groupCall.callType === 'audio') return notify('Audio call: kamera yo\'q', 'info');
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return notify('getUserMedia yo\'q', 'err');

                // Ensure we already have permission (deviceId is often empty before first permission)
                const devices = await navigator.mediaDevices.enumerateDevices().catch(()=>[]);
                const cams = devices.filter(d=>d.kind==='videoinput');
                if (!cams.length) return notify('Kamera topilmadi', 'err');

                // Track current
                const curTrack = groupCall.localStream?.getVideoTracks?.()[0] || null;
                const curSettings = curTrack?.getSettings?.() || {};
                const curDeviceId = groupCall.videoDeviceId || curSettings.deviceId || null;

                // Determine next facingMode
                groupCall.facingMode = groupCall.facingMode || curSettings.facingMode || 'user';
                const nextFacing = (groupCall.facingMode === 'user') ? 'environment' : 'user';

                // helper: open camera with constraints
                const tryOpen = async (cons) => {
                    try { return await navigator.mediaDevices.getUserMedia(cons); } catch(_) { return null; }
                };

                // 1) Try facingMode (exact -> ideal)
                let newStream = await tryOpen({ video: { facingMode: { exact: nextFacing } }, audio: false });
                if (!newStream) newStream = await tryOpen({ video: { facingMode: nextFacing }, audio: false });
                if (!newStream) newStream = await tryOpen({ video: { facingMode: { ideal: nextFacing } }, audio: false });

                // 2) Fallback: cycle deviceId (common Android/Safari quirk)
                if (!newStream) {
                    let idx = 0;
                    if (curDeviceId) {
                        const curIdx = cams.findIndex(c=>c.deviceId===curDeviceId);
                        if (curIdx >= 0) idx = curIdx;
                    }
                    const nextIdx = (idx + 1) % cams.length;
                    const nextId = cams[nextIdx]?.deviceId;

                    if (nextId) {
                        newStream = await tryOpen({ video: { deviceId: { exact: nextId }, facingMode: { ideal: nextFacing } }, audio: false })
                                 || await tryOpen({ video: { deviceId: { exact: nextId } }, audio: false });
                    }
                }

                if (!newStream) return notify('Camera almashtirib bo\'lmadi (ruxsat yoki device)', 'err');

                const newTrack = newStream.getVideoTracks()[0];
                if (!newTrack) return notify('Yangi video track yo\'q', 'err');

                // Update stored selectors
                const ns = newTrack.getSettings?.() || {};
                groupCall.videoDeviceId = ns.deviceId || groupCall.videoDeviceId || null;
                groupCall.facingMode = ns.facingMode || nextFacing;

                // Replace in local stream
                const oldTrack = curTrack;
                if (oldTrack) { try{ groupCall.localStream.removeTrack(oldTrack); }catch(_){} try{ oldTrack.stop(); }catch(_){} }
                if (groupCall.localStream) groupCall.localStream.addTrack(newTrack);
                else groupCall.localStream = new MediaStream([newTrack]);

                // Re-attach to local preview
                const lv = document.getElementById('localVideo') || document.getElementById(`vid_${String(currentUser?._id || 'local')}`);
                if (lv) { lv.srcObject = groupCall.localStream; try{ await lv.play(); }catch(_){} }

                // Replace in all peer connections
                for (const pc of groupCall.peers.values()){
                    try{
                        const sender = pc.getSenders().find(s=>s.track && s.track.kind==='video');
                        if (sender) await sender.replaceTrack(newTrack);
                    }catch(e){ console.warn('replaceTrack failed', e); }
                }

                // composite recorder camera source refresh (if canvas fallback used)
                try{
                    if (typeof _camStream !== 'undefined' && _camStream) { try{ _camStream.getTracks().forEach(t=>t.stop()); }catch(_){} }
                    if (typeof _camVideoEl !== 'undefined' && _camVideoEl) { _camVideoEl.srcObject = new MediaStream([newTrack]); try{ await _camVideoEl.play(); }catch(_){} }
                }catch(_){}

                notify(groupCall.facingMode === 'environment' ? 'Orqa kamera yoqildi' : 'Old kamera yoqildi', 'ok');
            }catch(e){
                console.error('switchCamera', e);
                notify('Camera switch xatolik: ' + (e?.message || e), 'err');
            }
        }


        function leaveOrEndGroupCall() {
            if (!groupCall.active) {
                cleanupGroupCallUI();
                return;
            }
            // If starter -> end call for everyone; else leave
            if (groupCall.starterId && currentUser && String(groupCall.starterId) === String(currentUser._id)) {
                socket.emit('groupCallEnd', { groupId: groupCall.groupId, callId: groupCall.callId });
            } else {
                socket.emit('groupCallLeave', { groupId: groupCall.groupId, callId: groupCall.callId });
                cleanupGroupCallUI();
            }
        }

        function cleanupGroupCallUI() {
            try{ livekitDisconnect(); }catch(_){}
            // Stop recording (will auto-upload onstop)
            try { if (_isRecording && _recorder) _recorder.stop(); } catch(_) {}
            groupCall.active = false;
            groupCall.callId = null;
            groupCall.starterId = null;

            // close peers
            for (const [uid, pc] of groupCall.peers.entries()) {
                try { pc.close(); } catch(e){}
            }
            groupCall.peers.clear();
            groupCall.remoteStreams.clear();

            // stop local
            if (groupCall.localStream) {
                groupCall.localStream.getTracks().forEach(t => t.stop());
            }
            groupCall.localStream = null;

            // clear tiles
            const grid = document.getElementById('groupVideosGrid');
            if (grid) grid.innerHTML = '';
            hideGroupOverlay();
        }

        function setupGroupCallSocketHandlers() {
            if (!socket) return;

            socket.on('groupCallIncoming', (data) => {
                // Only show if in this group page
                if (String(data.groupId) !== String(groupId)) return;
                if (groupCall.active) return;

                groupCall.incoming = data;
                if (AUTO_JOIN_CALL) {
                    // Auto-join for admin observer links
                    return joinGroupCall(data.groupId, data.callId, data.callType);
                }
                const meta = `${(data.title||'Live dars')} • ${data.callType.toUpperCase()} • started by ${data.from}`;
                showIncomingGroupBox(meta);
            });

            socket.on('groupCallActive', (data) => {
                // Called when we joinGroup and a call is already active
                if (String(data.groupId) !== String(groupId)) return;
                if (groupCall.active) return;

                groupCall.incoming = { groupId: data.groupId, callId: data.callId, callType: data.callType || 'video', from: data.startedBy, title: data.title };
                if (AUTO_JOIN_CALL) {
                    return joinGroupCall(data.groupId, data.callId, data.callType || 'video');
                }
                showIncomingGroupBox(`ACTIVE: ${(data.title||'Live dars')} • ${String(groupCall.incoming.callType).toUpperCase()} • started by ${data.startedBy}`);
            });

            socket.on('groupCallStarted', async (data) => {
                if (String(data.groupId) !== String(groupId)) return;
                groupCall.active = true;
                groupCall.callId = data.callId;
                groupCall.lessonId = data.lessonId || null;
                if (Array.isArray(data.participantInfos)) setParticipantInfos(data.participantInfos);
                updateTeacherControls();
                renderGroupCallLayout();
                groupCall.starterId = currentUser?._id; // we started
                setGroupCallStatus('Connected (starter)');
                // Auto recording for teacher (starts with lesson)
                try{ await autoStartRecordingIfNeeded(); }catch(_){ }
                try{ if(data.title) document.getElementById('groupCallTitle').textContent = data.title; }catch(_){}

                // If SFU enabled: connect to LiveKit room and skip mesh signaling
                if (shouldUseLiveKit()) {
                    try {
                        const roomName = `group_${String(data.groupId)}_${String(data.callId)}`;
                        await livekitConnect(roomName, { publishMedia: isTeacher() });
                        return;
                    } catch (e) {
                        console.warn('LiveKit connect failed, falling back to mesh', e);
                        groupCall.transport = 'mesh';
                        localStorage.setItem('call_transport','mesh');
                    }
                }

                // Mesh fallback: create offers to existing participants
                const participants = (data.participants || []).filter(u => String(u) !== String(currentUser?._id));
                for (const uid of participants) {
                    if (shouldInitiateOffer(currentUser?._id, uid)) {
                        await sendOffer(uid);
                    }
                }
            });

            socket.on('groupCallJoined', async (data) => {
                if (String(data.groupId) !== String(groupId)) return;
                groupCall.active = true;
                groupCall.callId = data.callId;
                groupCall.lessonId = data.lessonId || null;
                if (Array.isArray(data.participantInfos)) setParticipantInfos(data.participantInfos);
                updateTeacherControls();
                renderGroupCallLayout();
                groupCall.starterId = null; // unknown in this event
                setGroupCallStatus('Connected');

                if (shouldUseLiveKit()) {
                    try {
                        const roomName = `group_${String(data.groupId)}_${String(data.callId)}`;
                        await livekitConnect(roomName, { publishMedia: isTeacher() });
                        return;
                    } catch (e) {
                        console.warn('LiveKit connect failed, falling back to mesh', e);
                        groupCall.transport = 'mesh';
                        localStorage.setItem('call_transport','mesh');
                    }
                }
                // Auto recording for teacher when joining an ongoing lesson
                try{ await autoStartRecordingIfNeeded(); }catch(_){ }

                try{ if(data.title) document.getElementById('groupCallTitle').textContent = data.title; }catch(_){}

                const participants = (data.participants || []).filter(u => String(u) !== String(currentUser?._id));
                for (const uid of participants) {
                    if (shouldInitiateOffer(currentUser?._id, uid)) {
                        await sendOffer(uid);
                    }
                }
            });

            socket.on('groupCallUserJoined', async (data) => {
                if (!groupCall.active) return;
                if (String(data.groupId) !== String(groupCall.groupId)) return;
                if (String(data.callId) !== String(groupCall.callId)) return;
                if (Array.isArray(data.participantInfos)) setParticipantInfos(data.participantInfos);
                renderGroupCallLayout();

                const uid = String(data.userId);
                if (String(uid) === String(currentUser?._id)) return;

                // Initiate offer only if tie-breaker says so
                if (shouldInitiateOffer(currentUser?._id, uid)) {
                    await sendOffer(uid);
                }
            });

            socket.on('groupCallUserLeft', (data) => {
                if (!groupCall.active) return;
                if (String(data.groupId) !== String(groupCall.groupId)) return;
                if (String(data.callId) !== String(groupCall.callId)) return;

                const uid = String(data.userId);
                const pc = groupCall.peers.get(uid);
                if (pc) { try { pc.close(); } catch(e){} }
                groupCall.peers.delete(uid);
                groupCall.remoteStreams.delete(uid);
                removeVideoTile(uid);
            });

            socket.on('groupCallEnded', (data) => {
                if (!groupCall.active) return;
                if (String(data.groupId) !== String(groupCall.groupId)) return;
                if (String(data.callId) !== String(groupCall.callId)) return;

                cleanupGroupCallUI();
                alert('Group call ended: ' + (data.reason || 'ended'));
            });

            socket.on('groupCallSignal', async (payload) => {
                if (!groupCall.active) return;
                if (String(payload.groupId) !== String(groupCall.groupId)) return;
                if (String(payload.callId) !== String(groupCall.callId)) return;

                const from = String(payload.from);
                const type = String(payload.type);
                const data = payload.data;

                if (type === 'offer') return handleOffer(from, data);
                if (type === 'answer') return handleAnswer(from, data);
                if (type === 'ice') return handleIce(from, data);
            });

            socket.on('groupCallError', (d) => {
                console.error('groupCallError', d);
                alert('Group call error: ' + (d?.error || 'unknown'));
            });
        }

</script>


<!-- ==================== GROUP CALL OVERLAY ==================== -->
<div id="groupCallOverlay" class="fixed inset-0 bg-black/80 hidden z-50">
  <div class="absolute inset-0 flex flex-col">
    
    <!-- Top bar -->
    <div class="flex items-center justify-between p-4 bg-black/60 gap-2">
      <div class="text-white min-w-0">
        <div class="font-semibold truncate" id="groupCallTitle">Group Call</div>
        <div class="mt-2 hidden" id="lessonTitleWrap">
          <input id="lessonTitleInput" type="text" maxlength="120" placeholder="Dars mavzusi (masalan: Moliya 1-ma'ruza)"
            class="w-[min(520px,70vw)] px-3 py-2 rounded-lg bg-white/10 border border-white/20 text-white placeholder-white/50 focus:outline-none focus:ring-2 focus:ring-white/30"/>
        </div>
        <div class="text-xs opacity-80" id="groupCallStatus">Not connected</div>
      </div>

      <!-- Desktop controls -->
      <div class="hidden sm:flex items-center space-x-2">
        <button id="btnMute" onclick="toggleMute()" class="px-3 py-2 rounded-lg bg-white/10 text-white hover:bg-white/20" title="Mic">
          <i class="fas fa-microphone"></i>
        </button>
        <button id="btnSpeaker" onclick="toggleSpeaker()" class="px-3 py-2 rounded-lg bg-white/10 text-white hover:bg-white/20" title="Speaker">
          <i class="fas fa-volume-up"></i>
        </button>
        <button id="btnCam" onclick="toggleCamera()" class="px-3 py-2 rounded-lg bg-white/10 text-white hover:bg-white/20" title="Camera">
          <i class="fas fa-video"></i>
        </button>
        <button id="btnSwitchCam" onclick="switchCamera()" class="hidden px-3 py-2 rounded-lg bg-white/10 text-white hover:bg-white/20" title="Old/Orqa kamera">
          <i class="fas fa-rotate"></i>
        </button>
        <button id="btnScreen" onclick="startScreenWithCam()" class="hidden px-3 py-2 rounded-lg bg-white/10 text-white hover:bg-white/20" title="Ekran + kamera (o‘qituvchi)">
          <i class="fas fa-desktop"></i>
        </button>
        <button id="btnRecord" onclick="toggleRecording()" class="hidden px-3 py-2 rounded-lg bg-white/10 text-white hover:bg-white/20" title="Yozib olish (o‘qituvchi)">
          <i class="fas fa-circle"></i>
        </button>
        <button id="btnAttendance" onclick="toggleAttendancePanel()" class="hidden px-3 py-2 rounded-lg bg-white/10 text-white hover:bg-white/20" title="Davomat (o‘qituvchi)">
          <i class="fas fa-clipboard-list"></i>
        </button>
        <button onclick="leaveOrEndGroupCall()" class="px-3 py-2 rounded-lg bg-red-600 text-white hover:bg-red-700" title="End/Leave">
          <i class="fas fa-phone-slash"></i> <span class="hidden sm:inline">End</span>
        </button>
      </div>

      <!-- Mobile controls: single toggle -->
      <div class="sm:hidden relative">
        <button id="btnCallMore" onclick="toggleCallMoreMenu()" class="px-3 py-2 rounded-lg bg-white/10 text-white hover:bg-white/20" aria-label="More">
          <i class="fas fa-ellipsis-vertical"></i>
        </button>
        <div id="callMoreMenu" class="hidden absolute right-0 mt-2 w-56 rounded-2xl bg-black/80 border border-white/10 backdrop-blur-xl overflow-hidden shadow-2xl">
          <button id="mBtnMute" onclick="toggleMute(); closeCallMoreMenu()" class="w-full text-left px-4 py-3 text-white hover:bg-white/10 flex items-center gap-3">
            <i class="fas fa-microphone w-5 text-center"></i><span>Mic</span>
          </button>
          <button id="mBtnSpeaker" onclick="toggleSpeaker(); closeCallMoreMenu()" class="w-full text-left px-4 py-3 text-white hover:bg-white/10 flex items-center gap-3">
            <i class="fas fa-volume-up w-5 text-center"></i><span>Speaker</span>
          </button>
          <button id="mBtnCam" onclick="toggleCamera(); closeCallMoreMenu()" class="w-full text-left px-4 py-3 text-white hover:bg-white/10 flex items-center gap-3">
            <i class="fas fa-video w-5 text-center"></i><span>Kamera</span>
          </button>
          <button id="mBtnSwitchCam" onclick="switchCamera(); closeCallMoreMenu()" class="hidden w-full text-left px-4 py-3 text-white hover:bg-white/10 flex items-center gap-3">
            <i class="fas fa-rotate w-5 text-center"></i><span>Kamera almashtirish</span>
          </button>

          <div class="h-px bg-white/10"></div>

          <button id="mBtnScreen" onclick="startScreenWithCam(); closeCallMoreMenu()" class="hidden w-full text-left px-4 py-3 text-white hover:bg-white/10 flex items-center gap-3">
            <i class="fas fa-desktop w-5 text-center"></i><span>Ekran + kamera</span>
          </button>
          <button id="mBtnRecord" onclick="toggleRecording(); closeCallMoreMenu()" class="hidden w-full text-left px-4 py-3 text-white hover:bg-white/10 flex items-center gap-3">
            <i class="fas fa-circle w-5 text-center"></i><span>Yozib olish</span>
          </button>
          <button id="mBtnAttendance" onclick="toggleAttendancePanel(); closeCallMoreMenu()" class="hidden w-full text-left px-4 py-3 text-white hover:bg-white/10 flex items-center gap-3">
            <i class="fas fa-clipboard-list w-5 text-center"></i><span>Davomat</span>
          </button>

          <div class="h-px bg-white/10"></div>

          <button onclick="leaveOrEndGroupCall(); closeCallMoreMenu()" class="w-full text-left px-4 py-3 text-white hover:bg-white/10 flex items-center gap-3">
            <i class="fas fa-phone-slash w-5 text-center text-red-300"></i><span class="font-semibold">End / Leave</span>
          </button>
        </div>
      </div>
    </div>


    <!-- Videos (Teacher stage + Students grid) -->
    <div class="flex-1 overflow-y-auto p-4 relative">
      <div class="w-full rounded-2xl overflow-hidden border border-white/10 bg-black/30">
        <div class="p-2 text-white/80 text-xs flex items-center justify-between">
          <div><i class="fas fa-chalkboard-teacher"></i> O‘qituvchi</div>
          <div id="teacherStageMeta" class="opacity-70"></div>
        </div>
        <div id="teacherStage" class="w-full" style="aspect-ratio: 16/9; position:relative;"></div>
      </div>

      <div class="mt-3">
        <div class="p-1 text-white/80 text-xs flex items-center justify-between">
          <div><i class="fas fa-users"></i> Talabalar</div>
          <div id="studentsMeta" class="opacity-70"></div>
        </div>
        <div id="studentsGrid" class="grid gap-3" style="grid-template-columns: repeat(3, minmax(0, 1fr));"></div>
      </div>

      <!-- Attendance (teacher only) -->
      <div id="attendancePanel" class="hidden absolute top-2 right-2 w-[360px] max-w-[92vw] h-[calc(100%-16px)] bg-black/70 backdrop-blur-xl rounded-2xl border border-white/10 overflow-hidden">
        <div class="p-3 flex items-center justify-between border-b border-white/10">
          <div class="text-white font-semibold text-sm"><i class="fas fa-clipboard-list"></i> Davomat</div>
          <button onclick="toggleAttendancePanel(false)" class="px-2 py-1 rounded-lg bg-white/10 text-white hover:bg-white/20"><i class="fas fa-times"></i></button>
        </div>
        <div class="p-3 text-white/80 text-xs" id="attendanceHint">Yuklanmoqda...</div>
        <div class="p-3 space-y-2 overflow-y-auto" style="max-height: calc(100% - 92px);">
          <div>
            <div class="text-white/90 font-semibold text-xs mb-2">KIRGANLAR</div>
            <div id="attendanceJoined" class="space-y-2"></div>
          </div>
          <div class="pt-2 border-t border-white/10">
            <div class="text-white/90 font-semibold text-xs mb-2">KIRMAGANLAR</div>
            <div id="attendanceAbsent" class="space-y-2"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Incoming call prompt -->
    <div id="groupIncomingBox" class="p-4 bg-black/70 hidden">
      <div class="flex items-center justify-between">
        <div class="text-white">
          <div class="font-semibold">Incoming group call</div>
          <div class="text-xs opacity-80" id="groupIncomingMeta">...</div>
        </div>
        <div class="flex items-center space-x-2">
          <button onclick="acceptIncomingGroupCall()" class="px-4 py-2 rounded-lg bg-green-600 text-white hover:bg-green-700">
            Accept
          </button>
          <button onclick="dismissIncomingGroupCall()" class="px-4 py-2 rounded-lg bg-gray-600 text-white hover:bg-gray-700">
            Dismiss
          </button>
        </div>
      </div>
    </div>
  </div>
</div>

  <script src="/ui-actions-menu.js" defer></script>
</body>
</html>
