<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Channel - UniConnect</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <script src="/socket.io/socket.io.js"></script>
  <style>
    .gradient-bg{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%)}
    .post-card{transition:transform .2s ease,box-shadow .2s ease}
    .post-card:hover{transform:translateY(-2px);box-shadow:0 10px 25px rgba(0,0,0,.08)}
    .focus-ring:focus{outline:none;box-shadow:0 0 0 3px rgba(102,126,234,.35)}
    .line-clamp-6{display:-webkit-box;-webkit-line-clamp:6;-webkit-box-orient:vertical;overflow:hidden}
  </style>
</head>

<body class="bg-gray-50 min-h-screen">
  <!-- Navigation -->
  <nav class="gradient-bg text-white h-16">
    <div class="container mx-auto px-4 h-full flex items-center justify-between">
      <a href="/channels.html" class="flex items-center space-x-2">
        <i class="fas fa-arrow-left"></i>
        <span class="font-semibold">Back to Channels</span>
      </a>
      <div class="flex items-center space-x-3">
        <a href="/search.html" class="p-2 hover:bg-white/10 rounded-full" title="Search"><i class="fas fa-search"></i></a>
        <a href="/profile.html" class="p-2 hover:bg-white/10 rounded-full" title="Profile"><i class="fas fa-user"></i></a>
        <button id="logoutBtn" class="px-3 py-1.5 rounded-lg bg-white/10 hover:bg-white/20 text-sm font-semibold">Logout</button>
      </div>
    </div>
  </nav>

  <main class="container mx-auto px-4 py-6">
    <!-- Error banner -->
    <div id="errorBanner" class="hidden mb-4 p-4 rounded-xl bg-red-50 border border-red-200 text-red-800">
      <div class="flex items-start justify-between gap-3">
        <div>
          <div class="font-semibold">Something went wrong</div>
          <div id="errorText" class="text-sm mt-1"></div>
        </div>
        <button class="text-red-800/70 hover:text-red-900" onclick="hideError()"><i class="fas fa-xmark"></i></button>
      </div>
    </div>

    <!-- Channel header -->
    <section class="bg-white rounded-2xl shadow-sm overflow-hidden">
      <div class="relative">
        <div id="coverBanner" class="h-44 bg-gray-200"></div>
        <div class="absolute left-6 -bottom-7 flex items-end gap-4">
          <div class="w-20 h-20 rounded-2xl bg-white shadow flex items-center justify-center overflow-hidden">
            <img id="channelAvatar" class="w-full h-full object-cover hidden" alt="Channel avatar"/>
            <div id="avatarFallback" class="w-full h-full gradient-bg flex items-center justify-center text-white text-2xl font-bold">C</div>
          </div>
          <div class="pb-2">
            <div class="flex flex-wrap items-center gap-2">
              <h1 id="channelName" class="text-2xl font-bold text-white drop-shadow"></h1>
              <span id="channelPrivacy" class="px-2 py-0.5 text-xs rounded-full bg-white/20 text-white"></span>
            </div>
            <div class="text-white/90 text-sm">
              <span id="channelUsername"></span>
              <span class="mx-2">â€¢</span>
              <span id="channelCategory"></span>
              <span class="mx-2">â€¢</span>
              <span id="channelUniversity"></span>
            </div>
          </div>
        </div>

        <div class="absolute right-4 top-4 flex items-center gap-2">
          <button id="subscribeBtn" class="px-4 py-2 rounded-xl bg-white text-gray-900 font-semibold hover:bg-gray-100 shadow">
            Subscribe
          </button>
          <button id="manageBtn" class="px-4 py-2 rounded-xl bg-white/10 text-white font-semibold hover:bg-white/20 border border-white/20">
            <i class="fas fa-gear mr-2"></i>Manage
          </button>
        </div>
      </div>

      <div class="pt-10 px-6 pb-6">
        <p id="channelDescription" class="text-gray-700"></p>

        
        <!-- Live Stream (owner broadcast, viewers watch) -->
        <div id="liveSection" class="mt-4 p-4 rounded-2xl bg-white border shadow-sm">
          <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-3">
            <div>
              <div class="flex items-center gap-2">
                <span class="inline-flex items-center justify-center w-8 h-8 rounded-full bg-gray-100 text-gray-700">
                  <i class="fas fa-broadcast-tower"></i>
                </span>
                <div>
                  <div class="font-semibold text-gray-900">Live stream</div>
                  <div id="liveStatusText" class="text-sm text-gray-600">Checking statusâ€¦</div>
                </div>
              </div>
              <div id="liveHint" class="text-xs text-gray-500 mt-1">
                Channel egasi Live boshlasa, shu yerda tomosha qilasiz. (WebRTC one-to-many)
              </div>
            </div>

            <div id="liveControls" class="flex flex-wrap gap-2 justify-start md:justify-end"></div>
          </div>

          <div id="livePlayerWrap" class="hidden mt-4">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
              <div class="rounded-2xl overflow-hidden border bg-black">
                <video id="liveRemoteVideo" autoplay playsinline controls class="w-full h-full" style="max-height:60vh; object-fit:cover;"></video>
              </div>
              <div class="rounded-2xl overflow-hidden border bg-black hidden" id="liveLocalWrap">
                <video id="liveLocalPreview" autoplay playsinline muted class="w-full h-full" style="max-height:60vh; object-fit:cover;"></video>
              </div>
            </div>

            <div class="mt-3 flex flex-wrap gap-2 text-sm">
              <span id="liveMeta" class="text-gray-600"></span>
            </div>
          </div>
        </div>

<div class="mt-4 grid grid-cols-1 md:grid-cols-3 gap-3">
          <div class="p-4 rounded-xl bg-gray-50 border">
            <div class="text-xs text-gray-500">Subscribers</div>
            <div id="subscriberCount" class="text-xl font-bold text-gray-900">0</div>
          </div>
          <div class="p-4 rounded-xl bg-gray-50 border">
            <div class="text-xs text-gray-500">Posts</div>
            <div id="postCount" class="text-xl font-bold text-gray-900">0</div>
          </div>
          <div class="p-4 rounded-xl bg-gray-50 border">
            <div class="text-xs text-gray-500">Total views</div>
            <div id="totalViews" class="text-xl font-bold text-gray-900">0</div>
          </div>
        </div>
      </div>
    </section>

    <!-- Composer (inline, no modal) -->
    <section id="composerSection" class="mt-6 bg-white rounded-2xl shadow-sm p-6">
      <div class="flex items-center justify-between mb-3">
        <h2 class="text-lg font-bold text-gray-900">Create a post</h2>
        <div class="text-xs text-gray-500">Share link preview works via the post permalink.</div>
      </div>

      <div class="grid grid-cols-1 gap-3">
        <input id="postTitle" class="w-full px-4 py-2 rounded-xl border focus-ring" placeholder="Title (optional)" />
        <textarea id="postContent" rows="4" class="w-full px-4 py-3 rounded-xl border focus-ring" placeholder="Write something... (you can include a URL)"></textarea>

        <div class="flex flex-wrap items-center gap-3">
          <label class="inline-flex items-center gap-2 px-4 py-2 rounded-xl border bg-gray-50 hover:bg-gray-100 cursor-pointer">
            <i class="fas fa-paperclip"></i>
            <span class="text-sm font-semibold">Attach media</span>
            <input id="postMedia" type="file" class="hidden" accept="image/*,video/*" />
          </label>

          <div id="mediaBadge" class="hidden items-center gap-2 text-sm text-gray-700 px-3 py-2 rounded-xl bg-gray-50 border">
            <i class="fas fa-file"></i><span id="mediaName"></span>
            <button class="ml-2 text-gray-500 hover:text-gray-800" onclick="clearMedia()" title="Remove">
              <i class="fas fa-xmark"></i>
            </button>
          </div>

          <div class="flex-1"></div>

          <button id="publishBtn" class="px-5 py-2.5 rounded-xl gradient-bg text-white font-semibold hover:opacity-95 disabled:opacity-60 disabled:cursor-not-allowed">
            <i class="fas fa-paper-plane mr-2"></i>Publish
          </button>
        </div>

        <div id="publishHint" class="text-xs text-gray-500"></div>
      </div>
    </section>

    <!-- Posts -->
    <section class="mt-6">
      <div class="flex items-center justify-between mb-3">
        <h2 class="text-lg font-bold text-gray-900">Posts</h2>
        <div class="flex items-center gap-2">
          <select id="sortSelect" class="px-3 py-2 rounded-xl border bg-white focus-ring text-sm">
            <option value="new">Newest</option>
            <option value="popular">Most liked</option>
            <option value="views">Most viewed</option>
          </select>
          <button id="refreshBtn" class="px-3 py-2 rounded-xl border bg-white hover:bg-gray-50 text-sm font-semibold">
            <i class="fas fa-rotate mr-2"></i>Refresh
          </button>
        </div>
      </div>

      <div id="postsContainer" class="space-y-4"></div>

      <div id="loading" class="hidden py-8 text-center text-gray-500">
        <i class="fas fa-spinner fa-spin mr-2"></i> Loading...
      </div>
    </section>
  </main>

  <!-- Manage channel modal -->
  <div id="manageModal" class="hidden fixed inset-0 z-50">
    <div class="absolute inset-0 bg-black/40" onclick="closeManage()"></div>
    <div class="relative mx-auto mt-10 max-w-3xl bg-white rounded-2xl shadow-xl overflow-hidden">
      <div class="p-5 border-b flex items-center justify-between">
        <div>
          <div class="text-lg font-bold text-gray-900">Channel settings</div>
          <div class="text-xs text-gray-500">Update avatar, banner, name, username and more.</div>
        </div>
        <button class="p-2 rounded-lg hover:bg-gray-100" onclick="closeManage()"><i class="fas fa-xmark"></i></button>
      </div>

      <div class="p-5 space-y-5">
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div class="p-4 rounded-xl border bg-gray-50">
            <div class="text-sm font-semibold mb-2">Avatar</div>
            <input id="avatarInput" type="file" accept="image/*" class="block w-full text-sm" />
            <button id="saveAvatarBtn" class="mt-3 px-4 py-2 rounded-xl gradient-bg text-white font-semibold">Upload avatar</button>
          </div>
          <div class="p-4 rounded-xl border bg-gray-50">
            <div class="text-sm font-semibold mb-2">Cover banner</div>
            <input id="bannerInput" type="file" accept="image/*" class="block w-full text-sm" />
            <button id="saveBannerBtn" class="mt-3 px-4 py-2 rounded-xl gradient-bg text-white font-semibold">Upload banner</button>
          </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label class="text-sm font-semibold text-gray-700">Name</label>
            <input id="editName" class="mt-1 w-full px-4 py-2 rounded-xl border focus-ring" />
          </div>
          <div>
            <label class="text-sm font-semibold text-gray-700">Username</label>
            <input id="editUsername" class="mt-1 w-full px-4 py-2 rounded-xl border focus-ring" />
            <div class="text-xs text-gray-500 mt-1">Used in links and search.</div>
          </div>
          <div>
            <label class="text-sm font-semibold text-gray-700">Category</label>
            <input id="editCategory" class="mt-1 w-full px-4 py-2 rounded-xl border focus-ring" />
          </div>
          <div>
            <label class="text-sm font-semibold text-gray-700">University</label>
            <input id="editUniversity" class="mt-1 w-full px-4 py-2 rounded-xl border focus-ring" />
          </div>
        </div>

        <div>
          <label class="text-sm font-semibold text-gray-700">Description</label>
          <textarea id="editDescription" rows="3" class="mt-1 w-full px-4 py-3 rounded-xl border focus-ring"></textarea>
        </div>

        <div class="flex items-center justify-between">
          <label class="inline-flex items-center gap-2">
            <input id="editIsPublic" type="checkbox" class="w-4 h-4" />
            <span class="text-sm font-semibold text-gray-700">Public channel</span>
          </label>

          <button id="saveChannelBtn" class="px-5 py-2.5 rounded-xl gradient-bg text-white font-semibold">
            <i class="fas fa-floppy-disk mr-2"></i>Save changes
          </button>
        </div>
      </div>
    </div>
  </div>

<script>
  // ----------------- Helpers -----------------
  const token = localStorage.getItem('token');
  if (!token) location.href = '/login.html';

  const authHeaders = () => ({
    'Authorization': 'Bearer ' + token,
    'Content-Type': 'application/json'
  });

  function showError(msg){
    const b = document.getElementById('errorBanner');
    document.getElementById('errorText').textContent = msg || 'Unknown error';
    b.classList.remove('hidden');
  }
  function hideError(){ document.getElementById('errorBanner').classList.add('hidden'); }

  const isObjectId = (v) => /^[0-9a-fA-F]{24}$/.test(String(v || ''));

  function escapeHtml(str){
    return String(str||'')
      .replaceAll('&','&amp;')
      .replaceAll('<','&lt;')
      .replaceAll('>','&gt;')
      .replaceAll('"','&quot;')
      .replaceAll("'","&#039;");
  }

  // ----------------- Page state -----------------
  const urlParams = new URLSearchParams(location.search);
  const channelId = urlParams.get('channelId') || urlParams.get('id');
  const focusPostId = urlParams.get('postId');

  if (!isObjectId(channelId)) {
    showError('Invalid or missing channelId in URL. Redirecting to channels list...');
    setTimeout(() => location.href = '/channels.html', 1200);
  }

  let socket = null;
  let channel = null;
  let posts = [];

  // ----------------- Live Stream (WebRTC one-to-many) -----------------
  let currentUserId = null;

  // Host state: viewerId -> RTCPeerConnection
  const liveHostPCs = new Map();

  // Viewer state: single RTCPeerConnection to host
  let liveViewerPC = null;

  let liveLocalStream = null;     // host local media (camera/screen)
  let liveIsHost = false;
  let liveIsLive = false;
  let liveHostId = null;
  let liveStartedAt = null;
  let liveMode = null;

  const ICE_SERVERS = (function buildIceServers(){
    const servers = [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun1.l.google.com:19302' }
    ];
    // Optional TURN (if you later add it)
    // You can set these in window.TURN_URL / TURN_USERNAME / TURN_CREDENTIAL in a <script> tag or server template.
    if (window.TURN_URL && window.TURN_USERNAME && window.TURN_CREDENTIAL) {
      servers.push({
        urls: String(window.TURN_URL),
        username: String(window.TURN_USERNAME),
        credential: String(window.TURN_CREDENTIAL)
      });
    }
    return servers;
  })();

  function decodeJwtPayload(tok){
    try{
      const parts = String(tok||'').split('.');
      if (parts.length < 2) return null;
      const base64 = parts[1].replace(/-/g,'+').replace(/_/g,'/');
      const json = decodeURIComponent(atob(base64).split('').map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));
      return JSON.parse(json);
    }catch(e){ return null; }
  }

  function getUserIdFromToken(tok){
    const p = decodeJwtPayload(tok);
    if (!p) return null;
    return p.userId || p.id || p._id || null;
  }

  function isChannelOwner(){
    const cid = channel?.creatorId?._id || channel?.creatorId;
    return cid && currentUserId && String(cid) === String(currentUserId);
  }

  function setLiveStatusText(text){
    const el = document.getElementById('liveStatusText');
    if (el) el.textContent = text;
  }

  function setLiveMeta(){
    const el = document.getElementById('liveMeta');
    if (!el) return;
    if (!liveIsLive) { el.textContent = ''; return; }
    const dt = liveStartedAt ? new Date(liveStartedAt) : null;
    const when = dt ? dt.toLocaleString() : '';
    el.textContent = `Host: ${liveHostId || '-'}  â€¢  Mode: ${liveMode || '-'}  â€¢  Started: ${when}`;
  }

  function showLivePlayer(show){
    const wrap = document.getElementById('livePlayerWrap');
    if (!wrap) return;
    if (show) wrap.classList.remove('hidden');
    else wrap.classList.add('hidden');
  }

  function setVideoEl(elId, stream){
    const v = document.getElementById(elId);
    if (!v) return;
    v.srcObject = stream || null;
    if (stream) {
      v.muted = (elId === 'liveLocalPreview');
      v.playsInline = true;
      v.autoplay = true;
    }
  }

  function renderLiveControls(){
    const box = document.getElementById('liveControls');
    if (!box) return;
    box.innerHTML = '';

    // Always show a refresh status button
    const btnPing = document.createElement('button');
    btnPing.className = 'px-3 py-2 rounded-xl bg-gray-100 text-gray-800 font-semibold hover:bg-gray-200 border';
    btnPing.innerHTML = '<i class="fas fa-sync mr-2"></i>Status';
    btnPing.onclick = () => { if (socket && socket.connected) socket.emit('channelLive:ping', { channelId }); };
    box.appendChild(btnPing);

    if (isChannelOwner()) {
      liveIsHost = true;

      if (!liveIsLive) {
        const btnCam = document.createElement('button');
        btnCam.className = 'px-3 py-2 rounded-xl bg-red-600 text-white font-semibold hover:bg-red-700';
        btnCam.innerHTML = '<i class="fas fa-video mr-2"></i>Start (Camera)';
        btnCam.onclick = () => startLive('camera');
        box.appendChild(btnCam);

        const btnScr = document.createElement('button');
        btnScr.className = 'px-3 py-2 rounded-xl bg-red-600 text-white font-semibold hover:bg-red-700';
        btnScr.innerHTML = '<i class="fas fa-desktop mr-2"></i>Start (Screen)';
        btnScr.onclick = () => startLive('screen');
        box.appendChild(btnScr);
      } else {
        const btnStop = document.createElement('button');
        btnStop.className = 'px-3 py-2 rounded-xl bg-gray-900 text-white font-semibold hover:bg-black';
        btnStop.innerHTML = '<i class="fas fa-stop mr-2"></i>Stop';
        btnStop.onclick = () => stopLive();
        box.appendChild(btnStop);
      }
    } else {
      // Viewer controls
      liveIsHost = false;

      if (liveIsLive) {
        const btnJoin = document.createElement('button');
        btnJoin.className = 'px-3 py-2 rounded-xl bg-indigo-600 text-white font-semibold hover:bg-indigo-700';
        btnJoin.innerHTML = '<i class="fas fa-play mr-2"></i>Join Live';
        btnJoin.onclick = () => joinLive();
        box.appendChild(btnJoin);

        const btnLeave = document.createElement('button');
        btnLeave.className = 'px-3 py-2 rounded-xl bg-gray-100 text-gray-800 font-semibold hover:bg-gray-200 border';
        btnLeave.innerHTML = '<i class="fas fa-door-open mr-2"></i>Leave';
        btnLeave.onclick = () => leaveLive();
        box.appendChild(btnLeave);
      } else {
        const btnDisabled = document.createElement('button');
        btnDisabled.className = 'px-3 py-2 rounded-xl bg-gray-100 text-gray-400 font-semibold border cursor-not-allowed';
        btnDisabled.innerHTML = '<i class="fas fa-circle mr-2"></i>Offline';
        btnDisabled.disabled = true;
        box.appendChild(btnDisabled);
      }
    }
  }

  async function startLive(mode){
    try {
      hideError();
      if (!socket || !socket.connected) throw new Error('Socket not connected');
      if (!isChannelOwner()) throw new Error('Only channel owner can start live');

      // Capture media
      let stream = null;
      if (mode === 'screen') {
        stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
      } else {
        stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      }
      liveLocalStream = stream;

      // Preview
      document.getElementById('liveLocalWrap').classList.remove('hidden');
      setVideoEl('liveLocalPreview', stream);

      socket.emit('channelLive:start', { channelId, mode });

    } catch (e){
      showError(e.message || 'Failed to start live');
    }
  }

  function stopTracks(stream){
    try{
      if (!stream) return;
      stream.getTracks().forEach(t => { try{ t.stop(); }catch(e){} });
    }catch(e){}
  }

  async function stopLive(){
    try {
      if (!socket || !socket.connected) return;
      socket.emit('channelLive:stop', { channelId });
    } catch(e){}
    cleanupLiveAll();
  }

  function cleanupHostPCs(){
    for (const [viewerId, pc] of liveHostPCs.entries()) {
      try { pc.close(); } catch(e){}
      liveHostPCs.delete(viewerId);
    }
  }

  function cleanupViewerPC(){
    try { if (liveViewerPC) liveViewerPC.close(); } catch(e){}
    liveViewerPC = null;
  }

  function cleanupLiveAll(){
    cleanupHostPCs();
    cleanupViewerPC();
    stopTracks(liveLocalStream);
    liveLocalStream = null;

    setVideoEl('liveLocalPreview', null);
    setVideoEl('liveRemoteVideo', null);

    document.getElementById('liveLocalWrap').classList.add('hidden');
    showLivePlayer(false);

    // keep status fields; they will be updated via status events
  }

  function joinLive(){
    try {
      hideError();
      if (!socket || !socket.connected) throw new Error('Socket not connected');
      socket.emit('channelLive:join', { channelId });
    } catch(e){ showError(e.message || 'Failed to join live'); }
  }

  function leaveLive(){
    try {
      if (socket && socket.connected) socket.emit('channelLive:leave', { channelId });
    } catch(e){}
    cleanupViewerPC();
    setVideoEl('liveRemoteVideo', null);
    showLivePlayer(false);
  }

  async function createHostPCForViewer(viewerId){
    const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
    liveHostPCs.set(viewerId, pc);

    // Add tracks to pc
    if (liveLocalStream) {
      liveLocalStream.getTracks().forEach(track => pc.addTrack(track, liveLocalStream));
    }

    pc.onicecandidate = (ev) => {
      if (ev.candidate) {
        socket.emit('channelLive:ice', { channelId, to: viewerId, candidate: ev.candidate });
      }
    };

    pc.onconnectionstatechange = () => {
      // optional: could display state per viewer
      // console.log('Host->Viewer pc state', viewerId, pc.connectionState);
      if (pc.connectionState === 'failed' || pc.connectionState === 'closed' || pc.connectionState === 'disconnected') {
        try { pc.close(); } catch(e){}
        liveHostPCs.delete(viewerId);
      }
    };

    const offer = await pc.createOffer({ offerToReceiveAudio: false, offerToReceiveVideo: false });
    await pc.setLocalDescription(offer);

    socket.emit('channelLive:offer', { channelId, to: viewerId, sdp: pc.localDescription });
  }

  async function ensureViewerPC(){
    if (liveViewerPC) return liveViewerPC;

    const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
    liveViewerPC = pc;

    pc.ontrack = (ev) => {
      // First stream is enough for viewer
      const [stream] = ev.streams || [];
      if (stream) {
        setVideoEl('liveRemoteVideo', stream);
        showLivePlayer(true);
      }
    };

    pc.onicecandidate = (ev) => {
      if (ev.candidate) {
        socket.emit('channelLive:ice', { channelId, candidate: ev.candidate });
      }
    };

    pc.onconnectionstatechange = () => {
      if (pc.connectionState === 'failed' || pc.connectionState === 'closed') {
        try { pc.close(); } catch(e){}
        liveViewerPC = null;
      }
    };

    return pc;
  }


  // ----------------- Socket -----------------
  function initSocket(){
    socket = io();
    socket.on('connect', () => {
      socket.emit('authenticate', token);
      if (isObjectId(channelId)) socket.emit('joinChannel', channelId);

      // Live status (non-intrusive)
      if (isObjectId(channelId)) socket.emit('channelLive:ping', { channelId });
    });

    socket.on('channelPost:new', (payload) => {
      if (payload?.channelId === channelId) {
        loadPosts(true);
      }
    });

    socket.on('channelPostComment:new', (payload) => {
      // Update comment section if open
      if (payload?.postId) {
        const box = document.querySelector(`[data-comments-box="${payload.postId}"]`);
        if (box && !box.classList.contains('hidden')) {
          loadComments(payload.postId);
        }
      }
    });
  }

    // Live: status updates for everyone (channel room listeners)
    socket.on('channelLive:status', (payload) => {
      try {
        if (!payload || payload.channelId !== channelId) return;
        liveIsLive = !!payload.isLive;
        liveHostId = payload.hostId || null;
        liveStartedAt = payload.startedAt || null;
        liveMode = payload.mode || null;

        if (liveIsLive) {
          setLiveStatusText('ðŸ”´ LIVE now â€¢ Viewers: ' + (payload.viewersCount ?? 'â€”'));
        } else {
          setLiveStatusText('Offline');
          // If live ended while watching, cleanup viewer PC
          cleanupViewerPC();
          setVideoEl('liveRemoteVideo', null);
          showLivePlayer(false);
        }

        setLiveMeta();
        renderLiveControls();
      } catch(e){}
    });

    // Host-only: viewer joined => host must create offer
    socket.on('channelLive:viewerJoin', async (payload) => {
      try {
        if (!isChannelOwner()) return;
        const viewerId = String(payload?.viewerId || '');
        const cid = String(payload?.channelId || '');
        if (!viewerId || cid !== channelId) return;
        if (!liveLocalStream) return; // host hasn't started capture

        // Avoid duplicate
        if (liveHostPCs.has(viewerId)) return;

        await createHostPCForViewer(viewerId);
      } catch(e){
        console.error('viewerJoin error', e);
      }
    });

    socket.on('channelLive:viewerLeft', (payload) => {
      try {
        if (!isChannelOwner()) return;
        const viewerId = String(payload?.viewerId || '');
        const cid = String(payload?.channelId || '');
        if (!viewerId || cid !== channelId) return;

        const pc = liveHostPCs.get(viewerId);
        if (pc) {
          try { pc.close(); } catch(e){}
          liveHostPCs.delete(viewerId);
        }
      } catch(e){}
    });

    // Viewer: receive offer from host
    socket.on('channelLive:offer', async (payload) => {
      try {
        if (!payload || String(payload.channelId||'') !== String(channelId)) return;
        const sdp = payload.sdp;
        if (!sdp) return;

        const pc = await ensureViewerPC();
        await pc.setRemoteDescription(new RTCSessionDescription(sdp));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);

        socket.emit('channelLive:answer', { channelId, sdp: pc.localDescription });
      } catch(e){
        showError(e.message || 'Failed to accept live stream');
      }
    });

    // Host: receive answer from viewer
    socket.on('channelLive:answer', async (payload) => {
      try {
        if (!isChannelOwner()) return;
        if (!payload || String(payload.channelId||'') !== String(channelId)) return;
        const viewerId = String(payload.from || '');
        const sdp = payload.sdp;
        if (!viewerId || !sdp) return;

        const pc = liveHostPCs.get(viewerId);
        if (!pc) return;

        await pc.setRemoteDescription(new RTCSessionDescription(sdp));
      } catch(e){
        console.error('host setRemote answer error', e);
      }
    });

    // ICE (both)
    socket.on('channelLive:ice', async (payload) => {
      try {
        if (!payload || String(payload.channelId||'') !== String(channelId)) return;
        const from = String(payload.from || '');
        const cand = payload.candidate;
        if (!cand) return;

        if (isChannelOwner()) {
          // ICE from viewer => add to that pc
          const pc = liveHostPCs.get(from);
          if (!pc) return;
          await pc.addIceCandidate(new RTCIceCandidate(cand));
        } else {
          // ICE from host => add to viewer pc
          if (!liveViewerPC) return;
          await liveViewerPC.addIceCandidate(new RTCIceCandidate(cand));
        }
      } catch(e){}
    });

    // Ended broadcast
    socket.on('channelLive:ended', (payload) => {
      try {
        if (!payload || String(payload.channelId||'') !== String(channelId)) return;
        setLiveStatusText('Offline');
        liveIsLive = false;
        setLiveMeta();
        renderLiveControls();
        cleanupLiveAll();
      } catch(e){}
    });

    socket.on('channelLive:started', (payload) => {
      try {
        if (!payload || String(payload.channelId||'') !== String(channelId)) return;
        // Host confirmation
        setLiveStatusText('ðŸ”´ LIVE now');
        showLivePlayer(true);
        setLiveMeta();
        renderLiveControls();
      } catch(e){}
    });

    socket.on('channelLive:joined', (payload) => {
      try {
        if (!payload || String(payload.channelId||'') !== String(channelId)) return;
        // Viewer joined: wait for offer
        setLiveStatusText('Joining liveâ€¦');
        showLivePlayer(true);
        setLiveMeta();
      } catch(e){}
    });

    socket.on('channelLive:error', (payload) => {
      try {
        showError(payload?.error || 'Live error');
      } catch(e){}
    });


  // ----------------- API -----------------
  async function apiGet(url){
    const res = await fetch(url, { headers: { 'Authorization': 'Bearer ' + token } });
    const data = await res.json().catch(()=> ({}));
    if (!res.ok) throw new Error(data.error || ('Request failed: ' + res.status));
    return data;
  }

  async function apiPost(url, body){
    const res = await fetch(url, { method:'POST', headers: authHeaders(), body: JSON.stringify(body||{}) });
    const data = await res.json().catch(()=> ({}));
    if (!res.ok) throw new Error(data.error || ('Request failed: ' + res.status));
    return data;
  }

  async function apiPut(url, body){
    const res = await fetch(url, { method:'PUT', headers: authHeaders(), body: JSON.stringify(body||{}) });
    const data = await res.json().catch(()=> ({}));
    if (!res.ok) throw new Error(data.error || ('Request failed: ' + res.status));
    return data;
  }

  // ----------------- Load channel -----------------
  async function loadChannel(){
    try{
      const data = await apiGet(`/api/channels/${channelId}`);
      channel = data.channel;

      // Cover banner
      const cover = document.getElementById('coverBanner');
      if (channel.coverBanner) {
        cover.style.backgroundImage = `url('${channel.coverBanner}')`;
        cover.style.backgroundSize = 'cover';
        cover.style.backgroundPosition = 'center';
      } else {
        cover.classList.add('gradient-bg');
      }

      // Avatar
      const avatarImg = document.getElementById('channelAvatar');
      const avatarFallback = document.getElementById('avatarFallback');
      const initial = (channel.name || 'C').trim().slice(0,1).toUpperCase();
      avatarFallback.textContent = initial;

      if (channel.avatar) {
        avatarImg.src = channel.avatar;
        avatarImg.classList.remove('hidden');
        avatarFallback.classList.add('hidden');
      } else {
        avatarImg.classList.add('hidden');
        avatarFallback.classList.remove('hidden');
      }

      // Texts
      document.getElementById('channelName').textContent = channel.name || 'Channel';
      document.getElementById('channelUsername').textContent = channel.username ? '@' + channel.username : '';
      document.getElementById('channelCategory').textContent = channel.category || 'other';
      document.getElementById('channelUniversity').textContent = channel.university || 'All universities';
      document.getElementById('channelDescription').textContent = channel.description || '';
      document.getElementById('channelPrivacy').textContent = channel.isPublic ? 'Public' : 'Private';

      // Stats
      document.getElementById('subscriberCount').textContent = channel.subscriberCount ?? (channel.subscribers?.length || 0);
      document.getElementById('postCount').textContent = channel.postCount ?? 0;
      document.getElementById('totalViews').textContent = channel.totalViews ?? 0;

      // Subscribe button
      const subBtn = document.getElementById('subscribeBtn');
      setSubscribeBtn(!!channel.isSubscribed);

      subBtn.onclick = async () => {
        try{
          const res = await apiPost(`/api/channels/${channelId}/subscribe`);
          setSubscribeBtn(!!res.subscribed);
          // refresh counts
          await loadChannel();
        }catch(e){ showError(e.message); }
      };

      // Manage button
      const manageBtn = document.getElementById('manageBtn');
      // Only creator or moderator can manage; server will enforce anyway.
      manageBtn.onclick = openManage;

      // Prefill manage form
      document.getElementById('editName').value = channel.name || '';
      document.getElementById('editUsername').value = channel.username || '';
      document.getElementById('editDescription').value = channel.description || '';
      document.getElementById('editCategory').value = channel.category || '';
      document.getElementById('editUniversity').value = channel.university || '';
      document.getElementById('editIsPublic').checked = !!channel.isPublic;

      // Live controls depend on ownership + status
      renderLiveControls();
      try { if (socket && socket.connected) socket.emit('channelLive:ping', { channelId }); } catch(e){}


    } catch(e){
      showError(e.message);
    }
  }

  function setSubscribeBtn(isSubscribed){
    const btn = document.getElementById('subscribeBtn');
    if (isSubscribed){
      btn.textContent = 'Subscribed';
      btn.className = 'px-4 py-2 rounded-xl bg-white/10 text-white font-semibold hover:bg-white/20 border border-white/20';
    } else {
      btn.textContent = 'Subscribe';
      btn.className = 'px-4 py-2 rounded-xl bg-white text-gray-900 font-semibold hover:bg-gray-100 shadow';
    }
  }

  // ----------------- Posts -----------------
  async function loadPosts(silent=false){
    if (!silent) document.getElementById('loading').classList.remove('hidden');
    try{
      const sort = document.getElementById('sortSelect').value;
      const data = await apiGet(`/api/channels/${channelId}/posts?sort=${encodeURIComponent(sort)}`);
      posts = data.posts || [];
      renderPosts();

      // Focus post
      if (focusPostId && isObjectId(focusPostId)) {
        setTimeout(() => focusPost(focusPostId), 200);
      }
    } catch(e){
      showError(e.message);
    } finally {
      if (!silent) document.getElementById('loading').classList.add('hidden');
    }
  }

  function buildPostPermalink(postId){
    const origin = window.location.origin;
    return origin + '/post/' + postId;
  }

  function renderPosts(){
    const container = document.getElementById('postsContainer');
    if (!posts.length){
      container.innerHTML = `
        <div class="bg-white rounded-2xl p-8 text-center text-gray-500 border">
          <div class="text-lg font-semibold text-gray-700">No posts yet</div>
          <div class="text-sm mt-1">Be the first to publish something.</div>
        </div>`;
      return;
    }

    container.innerHTML = posts.map(p => {
      const liked = Array.isArray(p.likes) ? p.likes.includes(getMyUserIdUnsafe()) : !!p.liked; // fallback
      const likeCount = p.likeCount ?? (p.likes?.length || 0);
      const media = p.mediaUrl ? renderMedia(p.mediaUrl, p.mediaType) : '';
      const permalink = buildPostPermalink(p._id);

      return `
      <article id="post_${p._id}" class="post-card bg-white rounded-2xl shadow-sm border overflow-hidden">
        <div class="p-5">
          <div class="flex items-start justify-between gap-3">
            <div>
              ${p.title ? `<div class="text-lg font-bold text-gray-900">${escapeHtml(p.title)}</div>` : ''}
              <div class="text-xs text-gray-500 mt-1">
                <span>${new Date(p.createdAt).toLocaleString()}</span>
                <span class="mx-2">â€¢</span>
                <span><i class="fas fa-eye mr-1"></i>${p.viewsCount ?? 0}</span>
              </div>
            </div>

            <div class="flex items-center gap-2">
              <button class="px-3 py-2 rounded-xl border bg-white hover:bg-gray-50 text-sm font-semibold" onclick="copyLink('${p._id}')">
                <i class="fas fa-link mr-2"></i>Copy link
              </button>
              <a class="px-3 py-2 rounded-xl border bg-white hover:bg-gray-50 text-sm font-semibold" href="${permalink}" target="_blank" rel="noopener">
                <i class="fas fa-arrow-up-right-from-square mr-2"></i>Open
              </a>
            </div>
          </div>

          <div class="mt-3 text-gray-800 whitespace-pre-wrap">${escapeHtml(p.content || '')}</div>

          ${media ? `<div class="mt-4">${media}</div>` : ''}

          <div class="mt-4 flex flex-wrap items-center gap-2">
            <button class="px-3 py-2 rounded-xl border text-sm font-semibold ${liked ? 'bg-red-50 border-red-200 text-red-700' : 'bg-white hover:bg-gray-50'}"
                    onclick="toggleLike('${p._id}')">
              <i class="fa-heart ${liked ? 'fas' : 'far'} mr-2"></i>
              <span id="likeCount_${p._id}">${likeCount}</span>
            </button>

            <button class="px-3 py-2 rounded-xl border bg-white hover:bg-gray-50 text-sm font-semibold"
                    onclick="toggleComments('${p._id}')">
              <i class="far fa-comment mr-2"></i>Comments
            </button>

            <div class="flex-1"></div>

            <a class="text-xs text-gray-500 hover:text-gray-800" href="/channel.html?channelId=${channelId}&postId=${p._id}">
              Permalink highlight
            </a>
          </div>

          <!-- Comments -->
          <div data-comments-box="${p._id}" class="hidden mt-4 border-t pt-4">
            <div id="comments_${p._id}" class="space-y-3"></div>
            <div class="mt-3 flex gap-2">
              <input id="commentInput_${p._id}" class="flex-1 px-4 py-2 rounded-xl border focus-ring" placeholder="Write a comment..." />
              <button class="px-4 py-2 rounded-xl gradient-bg text-white font-semibold" onclick="addComment('${p._id}')">Send</button>
            </div>
          </div>
        </div>
      </article>`;
    }).join('');
  }

  function renderMedia(url, type){
    if (type === 'video'){
      return `<video class="w-full rounded-xl border bg-black" controls src="${escapeHtml(url)}"></video>`;
    }
    // default image
    return `<img class="w-full rounded-xl border object-cover" src="${escapeHtml(url)}" alt="post media" />`;
  }

  // Token doesn't store user id reliably; try decode JWT payload (unsafe but fine for UI)
  function getMyUserIdUnsafe(){
    try{
      const payload = JSON.parse(atob(token.split('.')[1]));
      return payload.userId || payload.id || null;
    }catch(e){ return null; }
  }

  async function toggleLike(postId){
    try{
      const res = await apiPost(`/api/posts/${postId}/like`);
      const el = document.getElementById('likeCount_' + postId);
      if (el) el.textContent = res.likeCount;

      // Update local state quickly
      const me = getMyUserIdUnsafe();
      const p = posts.find(x => x._id === postId);
      if (p && me){
        p.likes = p.likes || [];
        if (res.liked) {
          if (!p.likes.includes(me)) p.likes.push(me);
        } else {
          p.likes = p.likes.filter(x => x !== me);
        }
      }
      renderPosts();
    }catch(e){
      showError(e.message);
    }
  }

  function focusPost(postId){
    const el = document.getElementById('post_' + postId);
    if (!el) return;
    el.scrollIntoView({ behavior:'smooth', block:'start' });
    el.classList.add('ring-4','ring-indigo-200');
    setTimeout(() => el.classList.remove('ring-4','ring-indigo-200'), 2400);
  }

  function copyLink(postId){
    const link = buildPostPermalink(postId);
    navigator.clipboard.writeText(link).then(() => {
      const hint = document.getElementById('publishHint');
      hint.textContent = 'Copied: ' + link;
      setTimeout(() => hint.textContent = '', 1500);
    }).catch(()=>{});
  }

  // ----------------- Comments -----------------
  async function toggleComments(postId){
    const box = document.querySelector(`[data-comments-box="${postId}"]`);
    if (!box) return;
    const isHidden = box.classList.contains('hidden');
    if (isHidden){
      box.classList.remove('hidden');
      await loadComments(postId);
    } else {
      box.classList.add('hidden');
    }
  }

  async function loadComments(postId){
    try{
      const res = await apiGet(`/api/posts/${postId}/comments`);
      const list = document.getElementById('comments_' + postId);
      const comments = res.comments || [];
      if (!comments.length){
        list.innerHTML = `<div class="text-sm text-gray-500">No comments yet.</div>`;
        return;
      }
      list.innerHTML = comments.map(c => `
        <div class="flex gap-3">
          <img class="w-9 h-9 rounded-full object-cover border" src="${escapeHtml(c.user?.avatar || 'https://ui-avatars.com/api/?name=User')}" />
          <div class="flex-1">
            <div class="text-sm font-semibold text-gray-900">${escapeHtml(c.user?.nickname || c.user?.username || 'User')}</div>
            <div class="text-sm text-gray-800 whitespace-pre-wrap">${escapeHtml(c.content)}</div>
            <div class="text-xs text-gray-500 mt-1">${new Date(c.createdAt).toLocaleString()}</div>
          </div>
        </div>
      `).join('');
    }catch(e){
      showError(e.message);
    }
  }

  async function addComment(postId){
    const input = document.getElementById('commentInput_' + postId);
    const content = input.value.trim();
    if (!content) return;
    input.value = '';
    try{
      await apiPost(`/api/posts/${postId}/comments`, { content });
      await loadComments(postId);
    }catch(e){
      showError(e.message);
    }
  }

  // ----------------- Composer -----------------
  const mediaInput = document.getElementById('postMedia');
  mediaInput.addEventListener('change', () => {
    const file = mediaInput.files && mediaInput.files[0];
    if (!file) return clearMedia();
    document.getElementById('mediaName').textContent = file.name;
    document.getElementById('mediaBadge').classList.remove('hidden');
    document.getElementById('mediaBadge').classList.add('inline-flex');
  });

  function clearMedia(){
    mediaInput.value = '';
    document.getElementById('mediaBadge').classList.add('hidden');
    document.getElementById('mediaBadge').classList.remove('inline-flex');
  }
  window.clearMedia = clearMedia;

  document.getElementById('publishBtn').addEventListener('click', publishPost);

  async function uploadMedia(file){
    const form = new FormData();
    form.append('media', file);
    const res = await fetch(`/api/channels/${channelId}/posts/upload`, {
      method: 'POST',
      headers: { 'Authorization': 'Bearer ' + token },
      body: form
    });
    const data = await res.json().catch(()=> ({}));
    if (!res.ok) throw new Error(data.error || 'Upload failed');
    return data;
  }

  async function publishPost(){
    const btn = document.getElementById('publishBtn');
    const title = document.getElementById('postTitle').value.trim();
    const content = document.getElementById('postContent').value.trim();
    const file = mediaInput.files && mediaInput.files[0];

    if (!content && !file) {
      showError('Please write something or attach media.');
      return;
    }

    btn.disabled = true;
    try{
      let mediaUrl = '';
      let mediaType = '';

      if (file) {
        const up = await uploadMedia(file);
        mediaUrl = up.url || '';
        mediaType = up.type || '';
        if (mediaType === 'image' || mediaType === 'video') {} else {
          // fallback: infer
          mediaType = file.type.startsWith('video/') ? 'video' : 'image';
        }
      }

      await apiPost(`/api/channels/${channelId}/posts`, { title, content: content || '(media)', mediaUrl, mediaType });

      document.getElementById('postTitle').value = '';
      document.getElementById('postContent').value = '';
      clearMedia();
      await loadPosts(true);
    } catch(e){
      showError(e.message);
    } finally {
      btn.disabled = false;
    }
  }

  // ----------------- Manage channel -----------------
  function openManage(){
    document.getElementById('manageModal').classList.remove('hidden');
  }
  function closeManage(){
    document.getElementById('manageModal').classList.add('hidden');
  }
  window.closeManage = closeManage;

  document.getElementById('saveChannelBtn').addEventListener('click', async () => {
    try{
      const payload = {
        name: document.getElementById('editName').value.trim(),
        username: document.getElementById('editUsername').value.trim(),
        description: document.getElementById('editDescription').value.trim(),
        category: document.getElementById('editCategory').value.trim(),
        university: document.getElementById('editUniversity').value.trim(),
        isPublic: document.getElementById('editIsPublic').checked
      };
      await apiPut(`/api/channels/${channelId}`, payload);
      closeManage();
      await loadChannel();
    }catch(e){ showError(e.message); }
  });

  async function uploadChannelImage(kind){
    const input = document.getElementById(kind === 'avatar' ? 'avatarInput' : 'bannerInput');
    const file = input.files && input.files[0];
    if (!file) { showError('Please choose a file first.'); return; }

    const form = new FormData();
    form.append(kind, file);

    const endpoint = kind === 'avatar' ? 'avatar' : 'banner';
    const res = await fetch(`/api/channels/${channelId}/${endpoint}`, {
      method: 'POST',
      headers: { 'Authorization': 'Bearer ' + token },
      body: form
    });
    const data = await res.json().catch(()=> ({}));
    if (!res.ok) throw new Error(data.error || 'Upload failed');
    return data;
  }

  document.getElementById('saveAvatarBtn').addEventListener('click', async () => {
    try{ await uploadChannelImage('avatar'); await loadChannel(); }
    catch(e){ showError(e.message); }
  });

  document.getElementById('saveBannerBtn').addEventListener('click', async () => {
    try{ await uploadChannelImage('banner'); await loadChannel(); }
    catch(e){ showError(e.message); }
  });

  // ----------------- Actions -----------------
  document.getElementById('refreshBtn').addEventListener('click', () => loadPosts(false));
  document.getElementById('sortSelect').addEventListener('change', () => loadPosts(false));

  document.getElementById('logoutBtn').addEventListener('click', () => {
    localStorage.removeItem('token');
    location.href = '/login.html';
  });

  // ----------------- Init -----------------
  (async function init(){
    // Identify current user (from JWT)
    currentUserId = getUserIdFromToken(token);

    initSocket();
    await loadChannel();
    renderLiveControls();
    // initial ping (also done on socket connect)
    try { if (socket && socket.connected) socket.emit('channelLive:ping', { channelId }); } catch(e){}

    await loadPosts(false);
  })();
</script>
</body>
</html>
